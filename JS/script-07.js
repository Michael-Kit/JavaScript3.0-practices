//!!! Об'єктна модель документація
// JavaScript у браузері
// Коли JavaScript виконується у браузері, у нього є додатковий функціонал для роботи з вкладкою.Цей функціонал складається
// з таких модулів: ECMAScript, DOM, BOM.

//     ECMAScript(скорочено ES) — це стандарт, який описує мову програмування JavaScript.Цей стандарт визначає синтаксис і
// семантику мови, а також набір вбудованих об'єктів і функцій для роботи з даними, текстом, датами та іншими аспектами
// програмування.ECMAScript надає основну структуру мови, на якій базується JavaScript.Різні версії JavaScript реалізуються
// через різні версії стандарту ECMAScript.Наприклад, ES5, ES6(або ES2015), ES2016, ES2017 тощо — це різні версії ECMAScript,
// які впроваджують нові можливості та покращення в мову.
// Об'єктна модель документа (Document Object Model) — незалежний інтерфейс для роботи з HTML-документом. Ця модель містить
// набір властивостей і методів, що дозволяють шукати, створювати й видаляти елементи, реагувати на дії користувача і багато
// іншого, тобто поєднує сторінку з мовою програмування.

// DOM — це відображення HTML - документа.Виглядає як деревоподібна структура, у якій кожен вузол — це JavaScript - об'єкт
// із властивостями та методами, що становить частину HTML - документа.Кожен елемент у документі, весь документ в цілому,
// заголовок, посилання, абзац — це частини DOM цього документа, тому всі вони можуть бути змінені з JavaScript - коду.

// Об'єктна модель браузера (Browser Object Model) — незалежний від мови інтерфейс для роботи з браузером. Містить набір
// властивостей і методів, що дозволяють отримати доступ до ряду функцій браузера.Саме завдяки BOM можна отримувати розміри
// вікна браузера, читати URL, працювати з історією навігації, місцем розташування тощо.

//? HTML-документ і DOM

// Згідно з DOM-моделлю, кожен тег утворює окремий елемент-вузол (element node), а кожен фрагмент тексту всередині
// елемента — текстовий вузол (text node).

// HTML - документ — це ієрархічне дерево, у якому кожен елемент(окрім кореневого) вкладений в один батьківський елемент.

// На схемі бачимо, що елемент html розташовується всередині document.Отже, document — це батьківський елемент для html.
// Аналогічно, html— батьківський елемент для[head](<http://head.nf>) і body. У document нема батьківського елемента,
// бо document — це кореневий елемент.За рахунок вкладеної структури тегів і текстових елементів утворюється ієрархічне дерево.
// Як складається DOM-дерево?
// Щоб відобразити HTML-документ, браузер спочатку перетворює його у формат, який він розуміє — DOM.Інтерпретатор браузера має
// спеціальний фрагмент коду — HTML-парсер, який використовується для перетворення HTML у DOM.
// Браузер будує DOM поступово, щойно надходять перші фрагменти коду, він починає парсити HTML, додаючи вузли в деревоподібну структуру.
// Після того як DOM-дерево побудовано, у ньому можна знайти елемент за допомогою JavaScript.Оскільки кожен елемент має інтерфейс
// із безліччю властивостей і методів, з ним можна виконувати необхідні дії.

//todo  Test:

// Який елемент є кореневим у DOM-дереві?

// window
//* document
// html
// body
// Result

//* У DOM-дереві document — це кореневий елемент, він не вкладений ні в один батьківський елемент.

//!!! Пошук елементів

// Тобі вже відомо, що DOM - елемент — це об'єкт із властивостями й методами. Саме час навчитися швидко знаходити елемент
// за довільним CSS - селектором.
// Група методів elem.querySelector * — це сучасний стандарт для пошуку елементів.Вони дозволяють знайти елемент
// або групу елементів за CSS - селектором.

// element.querySelector(selector)
// Використовується, якщо необхідно знайти тільки один, найчастіше унікальний елемент.
// Повертає перший знайдений елемент усередині element, що відповідає рядку CSS - селектора selector.Навіть якщо їх декілька,
// завжди повернеться посилання тільки на перший елемент у DOM - дереві.
// Якщо нічого не знайдено, то поверне null
// Доступ до DOM починається з об'єкта document, з нього можна дістатися до будь-яких елементів. Об’єкт document — це частина
// глобального об'єкта window, який доступний у скрипті, коли він виконується в браузері. Так само як alert, console.log і багато інших.

// element.querySelectorAll(selector)

// Використовується, якщо необхідно знайти колекцію елементів, тобто отримати масив посилань на елементи з однаковим
// селектором.Наприклад, усі елементи списку з класом list - item.
// Повертає псевдомасив усіх елементів всередині element, які відповідають CSS-селектору selector
// Якщо нічого не знайдено, поверне порожній масив

//todo  Test:
//* Що має містити рядок, який передають аргументом методу querySelector?

//* CSS селектор елемента
// Клас елемента
// Ім’я тега
// Result

//* Точнісінько так! Рядок, який передають аргументом методу querySelector, має містити CSS-селектор selector елемента.

//todo  Test :

//     < h2 class="heading" > Latest news</ >

// Вибери правильний код для отримання посилання в JavaScript коді на HTML-елемент

// document.querySelectorAll(".heading")
//* document.querySelector(".heading")
// window.querySelector(".heading")
// querySelector(".heading")
// Result

//* Саме так! Правильний код для отримання посилання на HTML - елемент із класом "heading" у JavaScript коді — це
// document.querySelector(".heading").

//? Навігація по DOM

// Елементи DOM - дерева мають ієрархічне відношення один до одного.Для опису відносин використовуються терміни предок(ancestor),
// нащадок(descendant), батько(parent), дитина(child) і сусід(sibling).
// Найвищий елемент називається кореневим (root node).
// Кожен елемент, крім кореневого, має тільки один батьківський.
// В елемента може бути скільки завгодно дітей.
// Сусіди — це елементи зі спільним батьківським елементом.
// Дочірні елементи (діти) — елементи, що безпосередньо вкладені в поточний елемент (елементи першого рівня вкладеності).
// Нащадки — усі елементи, які знаходяться в поточному елементі, разом з їхніми дітьми, дітьми їхніх дітей тощо.Тобто все на
// зразок дерева.
                               
// На схемі < ul > — це батьківський елемент.Три елементи < li > — діти для < ul > і сусіди між собою.Так само елементи
//     < span >, <a>, <p> є сусідами. Усі вони — діти для <li> і нащадки для <ul>.
        
        
//!! Властивості та атрибути
//?  Доступ до властивостей

// Під час побудови DOM-дерева деякі стандартні HTML-атрибути стають властивостями елементів, тобто властивостями DOM-об’єктів.
// Розберемо приклад:

// Якщо в HTML є тег посилання,
// <a class="link" href="https://goit.global">GoIT</a>;
// то у JavaScript коді можна прочитати значення його атрибута href, отримавши посилання на елемент, тобто об'єкт,
// використовуючи querySelector, і звернутися до його властивості href
// const link = document.querySelector(".link");
// console.log(link.href); // "https://goit.global"
// Значення атрибутів можна змінювати, перевизначивши їм нове значення прямо з JavaScript коду, і під час виконання скрипта
// значення в HTML, тобто в DOM-дереві, зміниться.
// const link = document.querySelector(".link");
// console.log(link.href); // "https://goit.global"
// link.href = "https://neo.goit.global";
// console.log(link.href); // "https://neo.goit.global"

// У живому прикладі ми працюємо із зображенням і змінюємо значення його атрибутів src і alt, щоб зі скрипта підмінити картинку
// та її опис.

//?  Властивість textContent
// Властивість textContent повертає весь текстовий контент усередині елементів (власних і вкладених елементів).

// < p class="text" > Username: <span class=” sub-text”>Mango</span></ >
// Для отримання текстового контенту елемента, як завжди, отримуємо посилання на елемент і звертаємося до властивості через крапку.

// const el = document.querySelector(".text")
// const nested = document.querySelector(".sub-text")

// console.log(el.textContent); // "Username: Mango"
// console.log(nested.textContent); // "Mango"

// Властивість textContent можна як читати, так і змінювати.Неважливо, що буде передано в textContent, дані завжди будуть
// записані як текст.

// const el = document.querySelector(".text")
// console.log(el.textContent); // "Username: Mango"
// el.textContent = "Username: Poly";
// У живому прикладі ми змінюємо заголовок статті.

//todo Test:
// Що зберігає властивість textContent?

// URL-адресу поточної сторінки
// HTML-код вмісту елемента
//* Текстовий вміст елемента без HTML-тегів
// Result

//* Саме так! Властивість textContent зберігає текстовий вміст елемента без HTML-тегів.

//? Властивість classList

// Для того щоб із JavaScript коду прочитати, додати, видалити або перевірити наявність CSS - класу в елемента, у властивості
// classList зберігається об'єкт із методами для роботи з CSS-класами елемента.

// <a class="link is-active" href="https://goit.global">GoIT</a>
//     Властивість classList — це спеціальний тип об’єкта, який подібний до масиву.Зверни увагу, що він схожий, але не є нативним
// JavaScript - масивом, який ми вивчали раніше.Він зберігає в собі весь перелік класів DOM - елемента, властивість length і властивість value.
// властивість value містить точне значення атрибута class
// властивість length — кількість класів в елемента
// Але самі по собі value та length майже не використовуються, тому що для операцій з класами(додавання, видалення тощо)
// є спеціальні методи.

// const link = document.querySelector(".link");
// console.log(link.classList);
// ["link", "is-active", length: 2, value: "link is-active"]
// Метод classList.contains(className)
// Метод очікує аргументом рядок з іменем класу та повертає true або false, залежно від наявності класу className в елемента.
// Зверни увагу, що className передаємо як рядок без крапки (без селектора класу).

// const hasActiveClass = link.classList.contains("is-active"); // true
// const hasActiveClass = link.classList.contains("title"); // false

// Метод classList.add(className)
// Метод очікує аргументом рядок з іменем класу та додає клас className до списку класів елемента.

// link.classList.add("special");
// console.log(link.classList);
// ["link", "is-active", "special", length: 3, value: "link is-active special"]
// Можна додавати більше одного класу, вказавши кілька аргументів через кому.
// Метод classList.remove(className)
// Метод очікує аргументом рядок з іменем класу та видаляє клас className зі списку класів елемента.

//     link.classList.remove("is-active");
// console.log(link.classList);
// ["link", "special", length: 2, value: "link special"]
// Якщо спробувати видалити клас, якого не існує на елементі, то це не викличе помилку. Просто нічого не видалиться.
// Метод classList.toggle(className)
// Метод працює як перемикач:
// якщо клас className відсутній, то додає його в кінець списку класів
// і навпаки, якщо клас className присутній — видаляє його
// link.classList.toggle("is-active");
// console.log(link.classList);
// ["link", "special", "is-active", length: 3, value: "link special is-active"]
// Метод classList.replace(oldClassName, newClassName)
// Метод очікує 2 аргументи рядка(перший — стара назва класу, другий — нова назва класу) та замінює існуючий клас oldClassName
// на вказаний newClassName.

// link.classList.replace("special", "regular");
// console.log(link.classList);
// ["link", "regular", "is-active", length: 3, value: "link regular is-active"]

// Якщо спробувати поміняти клас, якого не існує на елементі, то це не викличе помилку. Просто нічого не поміняється.

//todo   Test:
// Як можна додати новий клас до списку класів елемента element?

// element.addClass("new-class");
// *element.classList.add("new-class");
// element.updateClass("new-class");
// Result

// * Абсолютно точно! Метод classList.add(className) додає клас className до списку класів елемента.Отже, правильний варіант —
// element.classList.add("new-class");

// Як можна видалити клас зі списку класів елемента element?

// element.removeClass("some-class");
// * element.classList.remove("some-class");
// element.classList.delete("some-class");
// Result

// *Саме так! Метод classList.remove(className) видаляє клас className зі списку класів елемента.Отже, правильний варіант —
// element.classList.remove("some-class");

//?  Властивість style
// Dластивість style використовується для читання та зміни вбудованих стилів з DOM - елементів.Вона повертає об'єкт,
// який містить список лише всіх вбудованих властивостей елемента, а не увесь CSS.
// Під час запису властивості вони записуються в camelCase нотації, замість дефісів, які зазвичай використовуються в CSS,
// тобто background - color перетворюється на backgroundColor.

// const button = document.querySelector(".btn");

// button.style.backgroundColor = "teal";
// button.style.fontSize = "24px";
// button.style.textAlign = "center";

// console.log(button.style); // inline styles object
// На практиці стилізація елементів зазвичай виконується шляхом додавання CSS-класів.
// Властивість style використовується для додавання будь - яких динамічних стилів, наприклад, якщо посилання на
// фонове зображення невідомо заздалегідь і приходить з бекенда.

//!    Доступ до атрибутів

// DOM-елементам відповідають HTML-теги, які містять текстові атрибути.
// Доступ до атрибутів здійснюється за допомогою стандартних методів.Ці методи працюють зі значенням,
// яке знаходиться в HTML.
// <img class="image" src="https://picsum.photos/id/15/320/240" alt="Rocks and waterfall" width="300" />
//? Метод element.hasAttribute(nameAttribute)
// Метод приймає один аргумент — рядок nameAttribute, який містить ім’я атрибута для перевірки та повертає результат
// перевірки його наявності на елементі element — true чи false.

// const image = document.querySelector(".image");
// console.log(image.hasAttribute("src")); // true
// console.log(image.hasAttribute("href")); // false

//? Метод element.getAttribute(nameAttribute)
// Метод отримує один аргумент — рядок nameAttribute з іменем атрибута, і повертає значення цього атрибута для вказаного
// HTML - елемента element.Якщо атрибут не знайдено, метод повертає null.
// console.log(image.getAttribute("alt")); // "Rocks and waterfall"
//? Метод element.setAttribute(nameAttribute, value)
// Метод приймає два аргументи: рядок nameAttribute з іменем атрибута, який потрібно встановити або змінити, та value
// зі значенням, яке цьому атрибуту треба присвоїти.Метод встановлює або змінює значення зазначеного атрибута для вказаного
// HTML - елемента element.

// image.setAttribute("alt", "Amazing nature");
// console.log(image.getAttribute("alt")); // Amazing nature
//? Метод element.removeAttribute(nameAttribute)
// Метод приймає один аргумент — рядок nameAttribute з іменем атрибута, який потрібно видалити зі вказаного HTML - елемента
// element — та видаляє його.Якщо зазначеного атрибута немає на елементі, метод не викликає жодних помилок та не робить нічого.
// image.removeAttribute("alt");
// console.log(image.hasAttribute("alt")); // false
// Отримати доступ або змінити значення деяких атрибутів елемента можна безпосередньо, звернувшись до них як до властивостей
// DOM - об'єкта. Це буде менш затратно за кількістю коду.
// А ось видалити або перевірити наявність буде зручніше, використовуючи відповідний метод.
//todo     TEST:
// Який метод перевіряє наявність певного атрибута в елемента?

// * hasAttribute
// getAttribute
// setAttribute
// removeAttribute
// Result

//*  Дуже добре! Метод element.hasAttribute(nameAttribute) приймає ім’я атрибута та перевіряє його наявність на елементі.

// Який метод дозволяє встановити значення певного атрибута на елементі?

// hasAttribute
// getAttribute
//* setAttribute
// removeAttribute
// Result

//* Так, правильно! Метод element.setAttribute(nameAttribute, value) встановлює атрибут з іменем nameAttribute і значенням value.

//!!  Власні атрибути
// Специфікацією HTML визначено вичерпний перелік атрибутів, які ми можемо додавати на ті чи інші теги (DOM-елементи) для того,
// щоб розмітка лишалась валідною, але інколи цього переліку недостатньо. Бувають випадки, коли нам потрібно зберегти певну інформацію на тезі, наприклад, вказати тип дії кнопки, щоб потім у певний момент часу мати можливість отримати до неї доступ. І тут на допомогу приходять власні data-атрибути.
// Власні атрибути дозволяють додати до тегу довільний атрибут і отримати його значення в JavaScript.
// <button type="button" data-action="save">Save text</button>
// <button type="button" data-action="close">Close editor</button>
//?  Отримання значень
// Для отримання значення data-атрибута використовується властивість dataset, після якої через крапку пишеться ім'я
// атрибута без data-. Тобто data- відкидається, а інша частина імені записується як ім'я властивості об'єкта.

// const saveBtn = document.querySelector('button[data-action="save"]');
// console.log(saveBtn.dataset.action); // "save"

// const closeBtn = document.querySelector('button[data-action="close"]');
// console.log(closeBtn.dataset.action); // "close"
// У живому прикладі ми працюємо з власними атрибутами.
//?  Зміна значень
// Змінити значення існуючого data - атрибута або додати новий можна так само, як і будь - якої іншої властивості об'єкта в JavaScript.
// Щоб це зробити, треба отримати доступ до DOM - елемента, а потім змінити / задати значення властивості в об'єкті dataset.
// Змінюємо значення data-action для кнопки saveBtn
// saveBtn.dataset.action = "update";

// Додаємо новий data-атрибут data-role
// saveBtn.dataset.role = "admin";

// Перевіримо нові значення
// console.log(saveBtn.dataset.action); // "update"
// console.log(saveBtn.dataset.role); // "admin"
// Тепер data-action атрибут для saveBtn має значення "update" замість "save".
// todo   Test: 
// Як отримати доступ до значення дата-атрибута data-type елемента element?

//* element.dataset.type
// element.data["type"]
// element["type"]
// element.dataset.dataType
// Result

//* доля отримання значення data - атрибута використовується властивість dataset,
// після якої через крапку пишеться ім'я атрибута без data-. Отже, правильна відповідь — element.dataset.type
