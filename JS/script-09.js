//!! Формат JSON
// Стандарт JSON
// JSON(JavaScript Object Notation) — сучасний текстовий формат зберігання й передачі структурованих даних у текстовій формі.
// Саме в цьому форматі дані будуть приходити і відправлятися на сервер, зберігатися в локальному сховищі тощо.
// Звичайний об'єктоподібний синтаксис JSON дуже зручний. Але JSON — це не об'єкт, а його рядкове відображення. Розгляньте приклад JSON файлу.

// Приклад JSON
// Це об'єкт, що містить різні типи даних: рядки, числа, масиви та інші об'єкти.
// {
//   "name": "Josh",
//   "weight": 175,
//   "age": 30,
//   "eyecolor": "brown",
//   "isHappy": true,
//   "cars": ["Chevy", "Honda"],
//   "favoriteBook": {
//     "title": "The Last Kingdom",
//     "author": "Bernard Cornwell",
//     "rating": 8.38
//   }
// }
// Синтаксис схожий на об'єкт, за винятком того, що:
// Ключі — це завжди рядки, обов'язково в подвійних лапках.
// Значення рядків — також обов'язково в подвійних лапках.
// Числа можуть бути цілими або десятковими, з десятковою крапкою або без неї, включаючи негативні.
// Числа та булеві значення true і false записуються так само, як у JavaScript.
// У JSON немає коми після останньої властивості об'єкта.
// Значення властивостей може бути спеціальним значенням null, але не може бути undefined.
// Функції не можна зберігати у JSON, оскільки JSON передбачений лише для даних, а не для методів обробки даних.
// JSON не підтримує коментарі, тому що це формат даних, а не код. Коментарі в JSON не допускаються.
// JSON не є JavaScript, але він дуже схожий на об'єкти JavaScript. Це дозволяє легко перетворювати об'єкти JavaScript у JSON і навпаки.
//todo Test:
// Вибери типи даних, які можна зберігати у JSON

//* Число
//* Рядок
// undefined
//* Масив
// Функція
//* null
// Result

//*  Чудово! У JSON зберігаються числа, рядки, масиви, а також спеціальне значення null.

// Прочитай приклад коду
// {
// 	username: "Jacob",
// 	age: 32,
// }

// Чи є код вище валідним JSON?

// Так
//* Ні
// Result

//* Ти дуже уважний/-а! JSON використовує подвійні лапки для ключів. У JSON також немає коми після останньої властивості об'єкта.

//? Перетворення у json

// Javascript і JSON чудово працюють разом, завдяки методам вбудованого класу JSON. Ці методи перетворюють JavaScript об'єкт у JSON і навпаки.
// Метод JSON.stringify(value) приймає значення і перетворює його у JSON. Значенням може бути число, буль, null, масив, об'єкт.
// Рядки — це вже валідний JSON, тому в їх перетворенні немає сенсу.

// const dog = {
//   name: "Mango",
//   age: 3,
//   isGoodBoy: true,
// };

// const json = JSON.stringify(dog);
// console.log(json); // '{"name":"Mango","age":3,"isGoodBoy":true}'

// Результат виклику JSON.stringify — це валідний JSON (рядок), який може бути збережений у вебсховище, базу даних або переданий мережею на сервер.
//todo  TEST:
// Який метод приводить дані до формату JSON?

// JSON.convert()
// JSON.toString()
// JSON.stringify()
// Result

// Саме так! Метод, який приводить дані до формату JSON, це JSON.stringify().

// Яким буде результат виклику JSON.stringify(32)?

// Число 32
//* Рядок “32”
// undefined
// Result

//* Абсолютно точно! JSON.stringify перетворює число 32 у відповідний рядок "32" у форматі JSON. Отже, результатом виклику JSON.stringify(32) буде рядок "32".

// Яким буде результат виклику JSON.stringify(true)?

// 1
//* Рядок “true”
// Буль true
// Result

//* JSON.stringify конвертує логічне значення true у відповідний рядок "true" у
// форматі JSON.Отже, результатом виклику JSON.stringify(true) буде рядок "true".

//?  Перетворення функцій

// Не всі JavaScript об'єкти можуть бути перетворені один в один у JSON. Наприклад,
// якщо в об'єкта є методи, то при перетворенні вони будуть проігноровані та не потраплять у JSON.

// const dog = {
//   name: "Mango",
//   age: 3,
//   isGoodBoy: true,
//   bark() {
//     console.log("Woof!");
//   },
// };

// const json = JSON.stringify(dog);
// console.log(json); // '{"name":"Mango","age":3,"isGoodBoy":true}'

// Також при спробі перетворити функцію у JSON результатом буде undefined.

// const json = JSON.stringify(() => console.log("Well, this is awkward"));
// console.log(json); // undefined

//todo  Test :
// Що буде з методами об'єкта при спробі перетворити його у json?

//* Вони будуть проігноровані
// Буде помилка перетворення
// Вони перетворяться на рядок
// Result

//* Усе правильно — при перетворенні у JSON методи об'єкта будуть проігноровані.

//?Парсинг із json

// Щоб отримати з JSON валідне JavaScript значення, його необхідно розпарсити(parse).
// Це операція зворотня перетворенню JavaScript об'єкта в json за допомогою методу
// JSON.stringify(value)
// Метод JSON.parse(value) приймає json, тобто рядок, і перетворює його у JavaScript
// дані.

// console.log(JSON.parse("5")); // 5
// console.log(JSON.parse("false")); // false
// console.log(JSON.parse("null")); // null

// Якщо json описує складний тип даних, наприклад об'єкт, то в результаті отримаємо валідний об'єкт, з яким можна працювати звичайним чином.

// const json = '{"name":"Mango","age":3,"isGoodBoy":true}';

// const dog = JSON.parse(json);
// console.log(dog); // {name: "Mango", age: 3, isGoodBoy: true}
// console.log(dog.name); // "Mango"
//todo  Test:
// Який метод парсить дані з json?

// JSON.toParse
// JSON.stringify
//* JSON.parse
// Result

//* Це правильна відповідь! Метод JSON.parse() парсить дані з JSON.

//?  Обробка помилок
// Якщо методу JSON.parse передати невалідний JSON, він згенерує помилку.Як результат,
// увесь скрипт впаде, тобто припинить своє виконання, і весь код після місця помилки
// не виконається.
// До такого сценарію призведе, наприклад, парсинг рядка.
// Рядок із символами — це невалідний JSON, адже він не може бути перетворений у валідне
// JavaScript значення.
// const data = JSON.parse("Hello, world!"); // Error
// console.log("❌ You won't see this log");
// const data = JSON.parse("Well, this is awkward");
// console.log("❌ You won't see this log");



// Помилка буде і при спробі парсингу невалідного об’єкта, який, наприклад,
// може прийти з бекенду.У прикладі у властивості username бракує подвійних лапок.
// Це невалідний JSON, адже ключі об'єкта мають бути в подвійних лапках.
// Якщо спробувати його розпарсити, то буде згенеровано помилку.
// const data = JSON.parse('{username: "Mango"}'); // Error
// console.log("❌ You won't see this log");

//*  Рішення
// Для уникнення цього використовується конструкція try...catch, яка дозволяє «ловити»
// й обробляти помилки виконання скрипта.

// try {
  // Code that may throw a runtime error
// } catch (error) {
  // Error handling
// }

// Спочатку виконується код всередині блоку try.
// Якщо помилки відсутні, блок catch ігнорується й управління передається далі.
// Якщо в блоці try сталася помилка, його виконання зупиняється та інтерпретатор
// переходить до блоку catch.
// Використовуючи конструкцію try...catch, можна обробити цей виняток таким чином,
// щоб скрипт за межами цієї конструкції продовжив працювати, навіть у разі помилки.

// try {
//   const data = JSON.parse("Well, this is awkward");
// } catch (error) {
//   console.log(error.name); // "SyntaxError"
//   console.log(error.message); // Unexpected token W in JSON at position 0
// }

// console.log("✅ This is fine, we handled parsing error in try...catch");
// У цьому прикладі, якщо сталася помилка під час парсингу, вона буде оброблена в
// блоці catch,
// а скрипт продовжить виконання, вивівши повідомлення "✅ This is fine, we handled
// parsing error in try...catch".
// Змінна error — це об'єкт помилки з інформацією про те, що сталося.
// У цього об'єкта є кілька корисних властивостей:
// name — тип помилки. Для помилки парсингу — це SyntaxError.
// message — повідомлення про деталі помилки.
// stack — стек викликів функцій на момент помилки. Використовується для налагодження.
//todo Test:
// Навіщо використовувати try...catch під час парсингу json?

// Щоб правильно розпарсити дані з формату json
//* Щоб у разі помилки парсингу скрипт не впав
// Щоб можна було розпарсити будь-який тип даних
// Result

//* Звісно, так і є! Використовуючи try...catch, можна визначити та обробити помилки парсингу JSON, щоб скрипт продовжив працювати.

// Коли виконується блок catch?

// Завжди після завершення виконання коду в блоці try
// Тільки у випадку, коли в блоці try не буде помилки
//* Тільки у випадку, коли в блоці try є помилка
// Result

//* Усе правильно — блок catch виконується тільки у випадку, коли в блоці try
// виникає помилка.

//? Детальніше про помилки

// У JavaScript код виконується не одразу.
// Для початку інтерпретатору потрібно прочитати код і дізнатися, чи можливо його
// взагалі виконати.

// Фаза інтерпретації, або оцінки(compile time, evaluation time) — підготовка перед
// виконанням коду: інтерпретатор знаходить синтаксичні помилки, помилки типізації тощо.
// Отже, код ще не виконується, лише оцінюється.
// Якщо ця фаза пройшла успішно, це щонайменше означає, що в коді відсутні синтаксичні
// помилки і його можна запустити для виконання.
// Фаза виконання(runtime) — скрипт починає виконуватися: виконуються інструкції
// викликів функцій і оцінювання виразів, відбувається пошук необхідних ідентифікаторів
// у відповідних областях видимості тощо.
// Якщо ця фаза проходить успішно, це свідчить про те, що скрипт написаний без явних
// помилок і виконав свою роботу.На цій фазі можуть бути помилки, пов'язані з відсутніми
// властивостями та змінними, перетворенням типів тощо, тобто щось, що відбувається
// тільки під час виконання коду.
// Спробуй виконати наступний код.
    
// console.log('This message will not appear in the console');

// cos value = 5;
// У ньому навмисно зроблена помилка.Замість const намагаємося оголосити змінну value
// ключовим словом cos.На фазі оцінки буде виявлена синтаксична помилка.Фаза виконання
// навіть не запуститься.У консолі ми одразу побачимо повідомлення про помилку.

// Конструкція try...catch ловить тільки помилки, які виникли під час виконання коду
// (runtime errors).Це означає, що код має бути синтаксично правильним, інакше фаза
// виконання просто не запуститься.Помилки, які виникають під час фази оцінювання,
//     називаються помилками парсингу.

    //!! Вебсховище
// //? Сookie
// Скільки разів тобі зустрічалося спливаюче вікно на вебсайті з написом:
// Цей вебсайт використовує файли cookie для зберігання вашої інформації.
// Скоріш за все, так часто, що можна збитися з рахунку!
// Свого часу вебсайти використовували протокол HTTP без збереження стану.Це означало,
// що вони не могли зберігати інформацію, пов’язану з користувачем, таку як
// ідентифікатор сеансу користувача, ім’я користувача, наповнення кошика товарів тощо,
// у веббраузері.
// З розвитком інтернету та його популярністю вебсайти почали зберігати інформацію,
// пов’язану з користувачем, у самому браузері.Це допомогло розрізняти тип користувача,
// який взаємодіє з їхнім вебсайтом, і забезпечити персоналізований досвід для
// користувача.
// Так з’явилися cookie(кукі).Вони надали механізм для зберігання невеликих фрагментів
// текстових даних клієнта або сервера у браузері як пари ключ - значення.Сookie також
// мають позначку часу закінчення терміну їх дії, після чого автоматично видаляються
// браузером.
// Браузер і сервер можуть установлювати та отримувати cookie з браузера користувача.
// Крім того, cookie можуть автоматично надсилатися разом із кожним HTTP - запитом на
// сервер.У результаті сервер може легко розпізнати інформацію користувача з кожним
// HTTP - запитом, який зробив користувач.
// Сookie використовуються й досі, але взаємодія з ними часто зводиться до встановлення
// та читання їх значень на сервері.Зазвичай це робиться за допомогою різних бібліотек,
// щоб спростити весь процес.
// Фронтенд рідко взаємодіє із вмістом cookie безпосередньо, оскільки вони можуть бути
// дещо обмеженими у використанні та мати обмежену ємність для зберігання даних.Щоб
// вирішити цю проблему, сучасні браузери мають власні механізми зберігання, такі як
// локальне сховище та сховище сеансів.

//? Web Storage API
// Cookie розв'язують проблему збереження інформації на стороні користувача під час
// взаємодії з вебсайтами.Водночас вони мають деякі обмеження.
// По - перше, їхні можливості обмежуються зберіганням даних розміром лише до кількох
// кілобайт.З ростом складності клієнтських програм виникла потреба зберігати більш
// об'ємні та складні дані прямо у браузері.
// З появою HTML5 на вебсайтах з'явилося API зберігання даних у браузері для ефективного
// управління інформацією на стороні користувача.Таким чином, будь - який JavaScript -
// код, що запускається у браузері, може легко отримати доступ до цих API.Основна
// відмінність полягає в тому, що ці механізми надавали більший об'єм для зберігання
// даних і можуть бути доступні лише для JavaScript, що виконувався на боці клієнта.
// Вебсховище — це механізм у веббраузерах, який дозволяє вебдодаткам зберігати та
// отримувати дані на стороні клієнта, тобто на комп'ютері користувача. Щоразу, коли
// ти змінюєш тему кольорів між світлою і темною, переглядаєш відео, додаєш товар у
// кошик, відкриваєш або закриваєш сайдбар, популярні вебзастосунки можуть
// запам'ятовувати стан інтерфейсу і в наступному відвідуванні відновлювати його.
// Вебсховище не зберігає паролі, номери банківських карт та іншу конфіденційну
// інформацію.Якщо шкідливий скрипт отримає доступ до вебсторінки, він без проблем
// зможе прочитати ці дані.
// Вебсховище складається з локального сховища та сховища сеансів.
// Локальне сховище(Local Storage): унікальне для кожного вебдодатку і буде
// однаковим на кількох вкладках, де вебдодаток відкритий.Дані в локальному сховищі
// не видаляються, навіть після закриття браузера або вимкнення комп'ютера. Щоб їх
// видалити, потрібно використовувати JavaScript.Доступ до даних у локальному сховищі
// можливий з будь - якої вкладки або вікна браузера, пов'язаної з доменом, який створив
// дані.
// Сховище сесії(Session Storage): на відміну від локального сховища, дані у сховищі
// сесії зберігаються лише протягом одної сесії браузера.Якщо користувач закриє вкладку
// або браузер, дані будуть видалені.Сховище сесії зручне для зберігання тимчасових
// даних або станів, які не повинні зберігатися довгий час.

//? Інструменти розробника

// Давай розглянемо, де у браузері знаходяться інструменти розробника для взаємодії з локальним сховищем і сховищем сеансу.

// Відкрий інструменти розробника у браузері та перейди на вкладку Application (укр. Додаток).
// У розділі Storage(укр.Пам’ять) **** ти знайдеш розділи під назвою Local Storage(укр.Локальна пам’ять)
// та Session Storage(укр. **** Пам’ять сеансу).
// Натисни на них, щоб побачити все, що зберігається в сховищі сеансу або локальному сховищі для цього вебсайту.

//? Локальне сховище
// Дані в локальному сховищі зберігаються у JSON форматі під певним ключем.Цей ключ може бути тільки рядком, і значенням
// виступає будь - що, що дозволяється JSON форматом.
// Локальне сховище може зберігати дані розміром від 5 Мб до 10 Мб.Точний обсяг пам’яті залежить від реалізації кожного б
// раузера, але це значно більше, ніж 4 Кб пам’яті, яку пропонують cookie.
// Дані в локальному сховищі не мають терміну зберігання за замовчуванням.Вони видаляються, лише якщо ти вручну видалиш ці
// дані з локального сховища безпосередньо, через налаштування браузера або за допомогою коду JavaScript.Це означає, що дані
// в локальному сховищі зберігаються навіть після закриття певної вкладки або вікна браузера.У кожного сайту своє окреме локальне
// сховище, тому збережені дані між сайтами не перетинаються.
// Доступ до локального сховища можна отримати в об’єкті window:

// console.log(window.localStorage);
// // Storage {length: 0}
// Це поверне довжину локального сховища разом з об’єктом, що представляє дані, які зараз присутні всередині.
// Оскільки спочатку він порожній, довжина дорівнює 0.
// Можна також отримати прямий доступ до об’єкта localStorage, адже за замовчуванням пошук відбувається на об’єкті window.
// console.log(localStorage);
// // Storage {length: 0}
// Завдяки тому, що дані в локальному сховищі не мають терміну зберігання за замовчуванням, цей тип сховища
// має цілу низку застосувань.Це всі ті сценарії, коли потрібно зберігати деякі глобальні дані, до яких часто звертаються у програмі.
// Наприклад, зміна теми кольорів між світлою і темною, перегляд відео, додавання товару в кошик, відкривання або закривання
// сайдбара, бажаний спосіб оплати користувача, адреси доставки за замовчуванням тощо, увесь цей стан інтерфейсу можливо зберегти
// і в наступному відвідуванні відновити його.

// todo Testb:

// Що таке localStorage в контексті веброзробки?

// Бібліотека для асинхронного завантаження ресурсів.
// Спеціальний клас для роботи з локальними файлами.
//* Механізм для зберігання даних у браузері клієнта.
// Result

//* Саме так! localStorage — це механізм для зберігання даних у браузері клієнта в режимі локального сховища.

// Чи зберігає localStorage дані під час перезавантаження сторінки?

// Так
// Ні
// Result

// Маєш рацію! Дані, збережені в localStorage, залишаються доступними у браузері клієнта, поки користувач не видалить їх вручну або поки не буде очищено кеш браузера.

// Якщо ти використовуєш localStorage на одному вебсайті і потім переходиш на інший вебсайт, чи буде доступ до даних, збережених у localStorage на першому вебсайті?

// Так, дані доступні на всіх вебсайтах.
//* Ні, дані доступні тільки на тому вебсайті, де вони були збережені.
// Result

//* Саме так! У кожного сайту своє окреме локальне сховище, тому збережені дані між сайтами не перетинаються.

//?  Додавання даних

// Давай додамо пару ключ-значення до локального сховища за допомогою методу setItem(key, value), доступного в об’єкті localStorage:
// localStorage.setItem("ui-theme", "light");
// Це встановить новий запис у сховищі з ключем "ui-theme" і значенням "light".Якщо ти просто викличеш об’єкт localStorage
// зараз, то побачиш збережені дані.

// console.log(localStorage); // Storage {ui-theme: "light", length: 1}

// Ти також побачиш це у браузері в розділі «Local Storage» в інструментах розробника:
// А що як у сховищі вже існував запис із ключем "ui-theme"?
// Виклик методу setItem(key, value) перезапише його значення.

//todo  Testb:
// Які аргументи приймає метод localStorage.setItem?

// Номер індексу та значення для зберігання
//* Ключ і значення для зберігання
// Тільки значення
// Result

//* Абсолютно точно! Метод localStorage.setItem приймає два аргументи: ключ і значення для зберігання.

// Що робить метод localStorage.setItem(key, value) у браузері?

// Отримує значення за ключем з localStorage
//* Встановлює значення для ключа в localStorage
// Видаляє ключ та його значення з localStorage
// Result

//* Варто запам’ятати, що метод localStorage.setItem(key, value) встановлює новий запис у сховищі.

// Якщо викликати localStorage.setItem("userData", "new_data");, і ключ "userData" вже існує в localStorage, що станеться ?

//* Значення для ключа "userData" буде оновлено на "new_data"
// Нічого не станеться, існуюче значення буде збережено
// Буде помилка запису
// Result

//* Супер! Якщо ключ "userData" вже існує в localStorage, то виклик localStorage.setItem("userData", "new_data");
// оновить значення для цього ключа на "new_data"

//? Додавання складних даних

// У вебсховище не записують методи об'єктів або функції, тільки дані, які підтримує
// JSON формат.
// Технічно у вебсховище можна записати тільки рядки.Але це не проблема, якщо
// використовувати методи класу JSON для перетворення складних типів.
// Якщо необхідно зберегти щось, окрім рядка, наприклад, масив або об'єкт,
// необхідно перетворити їх у рядок методом JSON.stringify().

// const settings = {
//   theme: "dark",
//   isAuthenticated: true,
//   options: [1, 2, 3],
// };

// localStorage.setItem("settings", JSON.stringify(settings));
// Тепер дані мають з’явитися в локальному сховищі браузера:

//todo  Tests:
// Які типи даних можна зберігати в локальному сховищі?

// Тільки об'єкти
//* Тільки рядки
// Будь-які типи даних
// Result

//* Точнісінько так! У вебсховище можна записати тільки рядки.

// Що потрібно зробити зі складними типами даних перед записом у локальне сховище?

// Привести їх до об'єкта
//* Привести їх до рядка
// Додати метод toString
// Result

//* Це логічно, чи не так? Якщо у вебсховище можна записати тільки рядки, перед записом у локальне сховище варто привести складні типи даних до рядка.

//? Отримання даних

// Метод getItem(key) дозволяє зчитати зі сховища запис із ключем key і повертає його
// значення у JSON форматі.

// const savedTheme = localStorage.getItem("ui-theme");
// console.log(savedTheme); // "light"

// Якщо у сховищі відсутній запис з таким ключем, метод повертає null.

// const savedItem = localStorage.getItem("key-that-does-not-exist");
// console.log(savedItem); // null

// Якщо значення є примітивним типом, немає потреби його парсити.
// В іншому випадку, якщо це масив або об'єкт, необхідно розпарсити значення методом

// JSON.parse(), щоб отримати валідні дані.

// const settings = {
//   theme: "dark",
//   isAuthenticated: true,
//   options: [1, 2, 3],
// };
// localStorage.setItem("settings", JSON.stringify(settings));

// const savedSettings = localStorage.getItem("settings");
// console.log(savedSettings); // A string

// const parsedSettings = JSON.parse(savedSettings);
// console.log(parsedSettings); // Settings object

// У змінній savedSettings буде рядок, що представляє об'єкт, тому ми розпарсюємо це
// значення, і у змінній parsedSettings отримуємо повноцінний об'єкт із властивостями.
//todo  Tests:
// Як отримати значення з localStorage за ключем "username"?

// localStorage.access("username")
// localStorage.getData("username")
//* localStorage.getItem("username")
// Result

//* Абсолютно точно! Для отримання значення з localStorage за ключем "username" слід використовувати
// метод localStorage.getItem("username")

// Що повертає метод localStorage.getItem("key"), якщо ключ "key" не існує в localStorage?

//* null
// undefined
// false
// Result

//* Ти все правильно пам’ятаєш: якщо у сховищі відсутній запис з таким ключем, метод повертає null.

// Який тип даних ти отримаєш із localStorage.getItem("age"), якщо раніше ти зберігав/-ла число 25 під ключем "age"?

//* Рядок (string)
// Число (number)
// Булеве значення (boolean)
// Result

//* Правильна відповідь! Локальне сховище зберігає всі дані у форматі рядка, тому виклик localStorage.getItem("age")
// поверне рядок.

//? Видалення даних

// Метод removeItem(key) видаляє зі сховища існуючий запис з ключем key. В результаті своєї роботи він не повертає значення.

// localStorage.setItem("ui-theme", "dark");
// console.log(localStorage.getItem("ui-theme")); // "dark"

// localStorage.removeItem("ui-theme");
// console.log(localStorage.getItem("ui-theme")); // null

// Якщо ти хочеш повністю очистити сховище, потрібно викликати метод clear().

// localStorage.setItem("ui-theme", "light");
// localStorage.setItem("notif-level", "mute");

// console.log(localStorage);
// Storage {notif-level: 'mute', ui-theme: 'light', length: 2}

// localStorage.clear();
// console.log(localStorage); // Storage {length: 0}

// Операція повного очищення сховища є ризикованою.Вона може порушити записи, створені іншими розробниками проєкту.
// Краще видаляти лише ті записи, які дійсно не потрібні, не покладаючись на повну очистку даних сховища.
//todo Tests:
// Який аргумент приймає метод localStorage.removeItem?

// Індекс значення, яке треба видалити
//* Ключ елемента, який треба видалити
// Значення елемента, яке треба видалити
// Result

//* Звісно! Метод localStorage.removeItem приймає аргументом ключ елемента, який потрібно видалити з localStorage.

// Як можна очистити всі дані в localStorage?

//* Використовуючи localStorage.clear()
// Викликаючи localStorage.removeAll()
// Встановивши всім ключам і значенням null
// Result

//* Чудово! Для очищення всіх даних у localStorage використовується метод localStorage.clear().

//!  Сховище сесії
// Сховище сесії зберігає дані лише доти, поки відкрита вкладка браузера.

// Це означає, що кожного разу, коли відкривається нова вкладка або нове вікно браузера, створюється нове сховище сесії.
// Отже, будь - які дані, які зберігаються в сховищі сесії, автоматично видаляються, коли користувач закриває цю вкладку / вікно.
// Набір методів та їхній функціонал ідентичні методам роботи з локальним сховищем.

// Єдиний виняток — звертаємося до них через об'єкт sessionStorage, а не localStorage.

// console.log(window.sessionStorage); // Storage {length: 0}
// Методом setItem(key, value) можна записувати як рядки, так і складні типи даних.
// sessionStorage.setItem("user-id", "123");
// sessionStorage.setItem(
//   "tickets",
//   JSON.stringify({ from: "Lviv", to: "Kyiv", quantity: 2 })
// );
// console.log(sessionStorage);
// Storage {user-id: '123', tickets: '{"from":"Lviv","to":"Kyiv","quantity":2}', length: 2}

// Методом getItem(key) можна читати записи, використовуючи збережений ключ.
// const userId = sessionStorage.getItem("user-id");
// console.log(userId); // "123"

// const tickets = JSON.parse(sessionStorage.getItem("tickets"));
// console.log(tickets); // { from: "Lviv", to: "Kyiv", quantity: 2 }
// І звісно, видаляти елементи за ключем і очищати сховище цілком методами removeItem(key) і clear() відповідно.

// sessionStorage.removeItem("tickets");
// console.log(sessionStorage); // Storage {user-id: '123', length: 1}

// sessionStorage.clear();
// console.log(sessionStorage); // Storage {length: 0}

// Оскільки дані в сховищі сеансу зберігаються лише на вкладці браузера, існує кілька унікальних випадків використання
// сховища сеансу.

// Зберігання сеансів можна використовувати в багатоетапних процесах: бронювання авіаквитків, готелів, квитків у кіно,
// поїздів тощо.Можна зберігати деталі попередніх кроків у сховищі сеансу браузера, щоб попередньо заповнити ці форми або введені дані.
// Ще одним прикладом можуть бути вебсайти для ведення блогів, інформаційні бюлетені, навчальні вебсайти тощо.
// Такі сторінки мають безліч відвідувачів, які читають вміст, не створюючи облікового запису.У таких сценаріях можна
// попросити відвідувача створити обліковий запис.Щоразу, коли він чи вона читає допис у блозі чи статтю на іншій вкладці.
// Це може бути чудовим способом запропонувати своїм користувачам неблокуючий досвід і водночас ефективно перетворити їх на
// зареєстрованих користувачів.

//!!  Кейс: Форма з повідомленням

// Створимо форму для введення повідомлення.

// <form class="feedback-form">
//   <textarea name="message"></textarea>
//   <button type="submit">Send feedback</button>
// </form>

// Під час сабміту форми будемо виводити в консоль значення текстового поля та очищати форму.

// const form = document.querySelector(".feedback-form");

// form.addEventListener("submit", evt => {
//   evt.preventDefault();
// 	console.log(evt.target.elements.message.value);
//   form.reset();
// });

//* Проблема
// Якщо користувач ввів повідомлення в текстове поле і перезавантажив сторінку, не надіславши форму, під час перезавантаження
// сторінки введене повідомлення пропадає.

//* Рішення
// Зробимо так, щоб при перезавантаженні сторінки зберігалося введене повідомлення.
// Для цього використовуємо локальне сховище, щоб зберегти поточне значення текстового поля під час введення.

// const form = document.querySelector(".feedback-form");
// const localStorageKey = "goit-example-message";

// form.addEventListener("input", (evt) => {
//   localStorage.setItem(localStorageKey, evt.target.value);
// });

// form.addEventListener("submit", (evt) => {
//   evt.preventDefault();
// 	console.log(evt.target.elements.message.value);
//   form.reset();
// });
// Щоразу, коли змінюється значення поля, тобто відбувається подія "input", ми:
// використовуємо делегування подій;
// ловимо подію на формі;
// використовуємо властивість target для запису поточного значення поля в локальне сховище.

// Під час сабміту форми будемо очищати збережене значення методом removeItem.

// const form = document.querySelector(".feedback-form");
// const localStorageKey = "goit-example-message";

// form.addEventListener("input", (evt) => {
//   localStorage.setItem(localStorageKey, evt.target.value);
// });

// form.addEventListener("submit", (evt) => {
//   evt.preventDefault();
// 	console.log(evt.target.elements.message.value);
//   localStorage.removeItem(localStorageKey);
//   form.reset();
// });
// Останнім кроком необхідно додати код читання збереженого повідомлення з локального сховища і встановлення
// його початковим значенням для текстового поля під час завантаження сторінки.

// const form = document.querySelector(".feedback-form");
// const textarea = form.elements.message;
// const localStorageKey = "goit-example-message";

// textarea.value = localStorage.getItem(localStorageKey) ?? "";

// form.addEventListener("input", (evt) => {
//   localStorage.setItem(localStorageKey, evt.target.value);
// });

// form.addEventListener("submit", (evt) => {
//   evt.preventDefault();
// 	console.log(evt.target.elements.message.value);
//   localStorage.removeItem(localStorageKey);
//   form.reset();
// });

// Змінюючи значення текстового поля і перезавантажуючи сторінку, можна побачити той самий текст, хоча нічого ще не вводили.
// Збереження об'єкта

//!!!!  Інструменти веброзробки

//? Автоматизація

// Інструменти автоматизації розробки вебпроєктів — це набір програмних засобів і скриптів, які спрощують та оптимізують рутинні завдання під 
// час процесу розробки вебдодатків. Вони допомагають автоматизувати багато аспектів розробки, зменшуючи час і зусилля, які розробники 
// витрачають на такі завдання.
// Основні завдання, які можуть бути автоматизовані завдяки інструментам автоматизації розробки вебпроєктів, включають такі:
// 1.Збірка та компіляція коду: Це включає в себе об'єднання та мініфікацію JavaScript і CSS файлів, компіляцію препроцесорів як 
// LESS або SASS в CSS, оптимізацію зображень тощо.

//* LESS — Leaner Style Sheets (тобто «Більш компактні таблиці стилів»)

//* SASS — Syntactically Awesome Style Sheets (тобто «Синтаксично круті таблиці стилів» 😎)

//*     Назви обидвох — це гра слів і трохи самоіронії розробників. 
//*     LESS натякає, що з ним ти пишеш менше коду, а
//*     SASS — що він стильний і потужний.
// 🧠 Лайфхак для запам’ятовування:
// LESS = «менше писати, більше результату»
// SASS = «стильно, але з характером» 💅
// 🧵 Уяви, що препроцесори — це чарівні олівці
// LESS і SASS — це спеціальні мови (такі собі чарівні олівці), які допомагають веброзробникам малювати гарні сторінки швидше 
// та зручніше. Але браузер не розуміє ці чарівні олівці напряму.

// 🪄 Що таке компіляція?
// Компіляція — це ніби коли ти взяв свій малюнок, зроблений чарівними олівцями (LESS або SASS), і перетворив його у просту картинку, 
// яку вже всі можуть побачити — тобто у звичайний CSS, який розуміє браузер.
// 2.Автоматичне тестування: Інструменти автоматизації дозволяють запускати тести на різних рівнях, таких як юніт-тести, інтеграційні 
// тести та енд-ту-енд тести, що допомагає виявляти помилки на ранніх етапах розробки.
// 3.Автоматичне розгортання: Інструменти автоматизації можуть допомогти автоматизувати процес розгортання вебдодатків на сервери або
// 3. Підтримка різних браузерів: Сучасні браузери підтримують різні стандарти і можуть потребувати різних версій коду. Інструменти 
// автоматизації дозволяють генерувати версії коду, які сумісні з різними браузерами, зменшуючи складність тестування та підтримки.
// 4.Лінтинг (перевірка на помилки) і тестування коду: Інструменти автоматизації можуть перевіряти твій код на наявність помилок, 
// дотримання код-стилю та виконання тестів автоматично під час розробки.
// 5.Управління залежностями та пакетами: Завдяки таким інструментам, як npm, ти можеш легко встановлювати, оновлювати та видаляти пакети 
// з твого проєкту.
// 6.Розгортання та виробнича збірка: Інструменти автоматизації допомагають створювати готовий для розгортання виробничий код. Це полегшує 
// розгортання та оновлення твого додатка, дозволяючи швидко впроваджувати зміни та виправлення помилок.
// 7.Моніторинг і тестування на виробництві: Деякі інструменти автоматизації дозволяють автоматично відслідковувати та аналізувати роботу 
// твого вебдодатка в реальному часі.
// 8.Генерація документації: З інструментами ти можеш автоматично створювати документацію для свого коду, що полегшує роботу над проєктом 
// команди та його документацію для користувачів.

// Інструменти автоматизації розробки значно покращують якість і продуктивність проєктів, допомагаючи розробникам концентруватися на розробці 
// функціональності, а не на рутинних роботах. Вони особливо корисні у великих проєктах або проєктах з командною розробкою, де ефективність 
// і співпраця є ключовими.
// Збірка проєкту з Vite
// Vite (https://vitejs.dev/) (французьке слово, що означає «швидкий», вимовляється [vit], як «veet») — це інструмент збірки проєкту 
//   для розробки вебдодатків на базі JavaScript. Він був створений для того, щоб забезпечити швидку та ефективну розробку вебпроєктів, 
//   а також максимально використовувати можливості сучасних вебстандартів.
// Основні особливості Vite:

// Швидка розробка: Vite відомий своєю швидкістю завантаження та перезавантаження, що дозволяє розробникам бачити зміни в реальному 
// часі практично миттєво після редагування коду. Це робить процес розробки більш продуктивним.
// Миттєве створення проєкту: Ти можеш створити новий проєкт за допомогою Vite за декілька секунд, завдяки готовому шаблону і швидкому 
// встановленню залежностей.
// Широкий спектр мов і технологій: Vite підтримує різні мови програмування (такі як JavaScript, TypeScript), CSS і декілька фреймворків, 
// зокрема Vue.js, React і Svelte. Можна вибрати те, що тобі підходить найкраще.
// Модульна система: Vite використовує сучасну модульну систему ESM, що дозволяє завантажувати модулі за потребою і сприяє ефективному 
// використанню ресурсів.
// Гаряча заміна модулів (HMR): Vite підтримує гарячу заміну модулів, що дозволяє вносити зміни в код і бачити їх відображення в реальному 
// часі без перезавантаження сторінки.
// Плагін-система: Розробник може легко розширити функціональність Vite, додаючи плагіни зі спільноти або створюючи власні.
// Вбудована підтримка CSS і препроцесорів CSS: Vite автоматично обробляє CSS і дозволяє використовувати різні препроцесори, такі як SASS 
// або LESS.


// Vite стає все більш популярним у середовищі фронтенд-розробників завдяки своїй швидкості та простоті використання. Він дозволяє розробляти 
// ефективні та модульні вебдодатки, зосереджуючись на тому, що важливо — функціональності.

//? Node.js

// Для того щоб використовувати сучасні інструменти веброзробки, необхідно встановити в операційну систему твого комп’ютера Node.js — 
// легке та ефективне середовище виконання JavaScript поза браузером.

// Спочатку Node.js створювався як серверне оточення для додатків, але розробники почали використовувати його для створення інструментів, 
// які допомагають автоматизувати виконання локальних завдань. У результаті нова екосистема інструментів, яка виникла навколо Node.js, 
// призвела до трансформації процесу фронтенд-розробки.

// Щоб встановити останню стабільну версію (LTS):

// Перейди на офіційну сторінку і завантаж LTS-інсталятор для своєї версії операційної системи: Windows, MacOS і Linux.

// Починаючи установку, обов'язково простав чек поряд з Automatically install the necessary tools.

// Якщо попередній етап був пропущений, користувачам Windows інструменти потрібно встановити через консоль вручну. Для цього запусти 
// Powershell від імені адміністратора і інсталюй інструменти в терміналі командою

// npm install --global --production windows-build-tools
// Дотримуйся подальших вказівок, які запропонує система, для завантаження інсталятора.
// На момент встановлення номер версії може відрізнятися, адже Node.js постійно оновлюється, головне взяти поточну LTS версію. 
// Після встановлення обов’язково перезавантаж свій комп'ютер, щоб Node.js повністю інтегрувався у твою операційну систему.
// Якщо встановлення пройшло успішно, у терміналі буде доступна команда node. Щоб переконатися, що встановлення пройшло успішно, 
// перевір версію, запустивши в консолі таку команду і натиснувши Enter.
//** */ node --version
// У результаті виконання команди буде виведено поточну встановлену версію. Твоя версія може відрізнятися, адже постійно виходять оновлення.

//? Пакетний менеджер NPM

// Щоб використовувати все різноманіття інструментів Node.js, нам необхідна можливість встановлювати їх та керувати ними. Для цього 
// створений NPM (node package manager) — пакетний менеджер Node.js. Він встановлює потрібні інструменти і забезпечує зручний інтерфейс 
// для роботи з ними.
// NPM сам встановлюється автоматично разом зі встановленням Node.js. Якщо інсталяція пройшла успішно, у терміналі буде доступна команда npm. 
// Щоб переконатися, що встановлення NPM пройшло успішно, перевір версію, запустивши в консолі таку команду і натиснувши Enter.
//** */ npm --version
// У результаті виконання команди буде виведено поточну встановлену версію NPM. Твоя версія може відрізнятися, адже постійно виходять оновлення.

// Тепер необхідно виконати початкове налаштування і конфігурацію npm, встановивши ім'я та пошту майбутнього автора проєктів — тебе.
// Щоб встановити ім'я, виконай у терміналі таку команду, підстав замість YOUR_NAME своє ім'я і не загуби лапки.
// npm config set init-author-name "YOUR_NAME"
// Ось як це може виглядати.
// Щоб встановити пошту, виконай у терміналі таку команду, підставивши замість "YOUR_EMAIL" свою пошту. Вкажи пошту, з якою ти 
// реєструвався/-лася на GitHub.
// npm config set init-author-email "YOUR_EMAIL"
// Ось як це може виглядати.
// Ініціалізація проєкту з Vite
// Перейди в терміналі до папки, в якій лежатимуть усі проєкти, наприклад, нехай вона називається projects. Це можна зробити командою 
// cd (Change Directory).
// Відкрий термінал.
// Використай команду cd для переходу до папки projects. Наприклад:

// cd C:/шлях/до/папки/projects   //для Windows
// cd /шлях/до/папки/projects     //для macOS
// або якщо папка projects знаходиться у твоєму домашньому каталозі (папка користувача):
// cd ~/projects
// Зверни увагу! 
// Залежно від операційної системи і типу терміналу, в ролі роздільника можуть бути слеши як backslash (\\), так і forward 
// slash (/), тому підбирай під свої умови.
// Тепер ти знаходишся в каталозі projects і можеш працювати з файлами і папками, які там розташовані.
// Для користувачів Windows рекомендується, щоб це була папка в корені диска, наприклад, C або D.
// Для користувачів MacOS місце розташування папки ні на що не впливає.
// Тепер у терміналі в цій папці виконай команду створення проєкту на базі Vite.
// npm create vite@latest
// Ось який вигляд має процес створення проєкту на відео.

// Відео
// https://goitlmsstorage.b-cdn.net/5d731668-a0df-4ae9-8549-82c1707561d42023-09-13%2016-16-50.mp4

// Вводимо команду початку створення проєкту й натискаємо Enter.
// На наступному кроці система може запитати, чи потрібно встановити пакет create-vite@latest, вводимо символ y (від слова “yes”) 
// і натискаємо Enter.
// Далі вводимо ім'я папки нашого проєкту, воно може бути довільним, у прикладі це my-vite-project.
// Тепер стрілками вгору/вниз обираємо стек технологій проєкту, нам необхідний Vanilla, підтверджуємо вибір і натискаємо Enter.
// Останнім кроком обираємо мову проєкту, у нашому випадку це JavaScript, підтверджуємо Enter.
// У результаті створюється папка (на ім'я проєкту) з деякими файлами в ній.
// Переходимо в терміналі в папку проєкту і відкриваємо її в VSCode.
// У VSCode ми бачимо index.html, main.js, style.css і кілька файлів для npm і Git, тобто каркас твого вебпроєкту.
// Файл package.json
// У результаті ініціалізації каркаса проєкту, крім стандартних файлів для написання коду і файлів налаштувань, створюється ще один 
// важливий файл package.json. Він відстежує залежності проєкту, містить службову інформацію, дає змогу писати npm-скрипти і слугує 
// інструкцією під час створення нового проєкту на основі вже готових налаштувань.
// У нашому package.json поки що є тільки сам збирач vite як залежність і кілька скриптів для запуску середовища розробки й процесу збірки.

// Цей файл можна редагувати вручну, наприклад для додавання скриптів. Його також буде автоматично оновлено щоразу при додаванні або 
// видаленні пакетів з проєкту.
// Встановлення залежностей
// Наступним кроком після ініціалізації проєкту в терміналі нам потрібно перейти до папки проєкту і встановити його залежності.
// Для цього виконуємо таку команду, яка встановить усі залежності проєкту:
// npm install
// або скорочена версія:
// npm iНа відео процес встановлення залежностей проєкту.
// // Відео
// https://goitlmsstorage.b-cdn.net/4d06e548-b026-42fc-aa0f-000c56c26f2c2023-09-13%2016-46-15.mp4
// NPM завантажує з реєстру всі залежності, зазначені у файлі package.json у властивостях dependencies (якого в нас ще немає) і 
// devDependencies, і поміщає їх у папку node_modules у корені проєкту, в якій перебуватимуть усі залежності.

// Папку node_modules ніколи не додають до системи контролю версій (не завантажують в репозиторій на github), у всіх розробників вона 
// буде своя. Під час ініціалізації проєкту Vite було створено файл .gitignore, до якого додано правило, що виключає папку node_modules 
// з переліку того, що необхідно завантажити в репозиторій на github.
// Зверни увагу на створений файл package-lock.json — це журнал знімків дерева залежностей проєкту. Він гарантує, що команда розробників 
// використовує однакові версії залежностей. NPM автоматично оновлює його при додаванні, видаленні та оновленні пакетів.
//todo  Tests:
// Яка команда npm встановить усі залежності проєкту?

//* npm install
// npm init
// npm download
// Result

//* Точнісінько так! Команда npm install встановить усі залежності проєкту, які зазначені у файлі package.json.

// У яку папку додаються залежності проєкту?

// app
//* node_modules
// public
// Result

//* Правильно! Залежності проєкту додаються у папку node_modules.

//?  Запуск сервера розробки

// У файлі package.json у полі scripts знаходиться список команд проєкту, які можна виконати в терміналі.

// {
//   "name": "my-vite-project",
//   "private": true,
//   "version": "0.0.0",
//   "type": "module",
//   "scripts": {
//     "dev": "vite",
//     "build": "vite build",
//     "preview": "vite preview"
//   },
//   "devDependencies": {
//     "vite": "^4.4.5"
//   }
// }
// Ім'я властивості (наприклад, “dev”) — це ім'я команди скрипта, який будемо запускати.
// Значення властивості (наприклад, "vite") — сам скрипт, який необхідно виконати. Тобто поле scripts містить псевдоніми 
// для часто використовуваних команд на проєкті.
// Для запуску скриптів використовується npm команда run.
//*  npm run [script-name]
// Замість [script-name] необхідно вказати ім'я скрипта, що запускається, з поля scripts.
// У нашому проєкті скрипт з ім'ям dev запускає локальний сервер розробки. Це сервер, який запускається на твоєму комп'ютері і 
// дає змогу розробляти й тестувати вебсайти та вебдодатки на локальному пристрої, перед тим як розміщувати їх в інтернеті.
// Запустимо локальний сервер розробки, виконавши команду:

// //* npm run dev

// Тепер можна подивитися додаток локально за адресою http://localhost:5173. При редагуванні будь-якого з файлів проєкту 
// зміни одразу ж відображаються на екрані.



// На відміну від усіх попередніх команд, результатом запуску сервера буде процес, який не завершується самостійно, поки сервер 
// запущено. Тобто це процес, який займає термінал і не дає можливості вводити інші команди.
// https://goitlmsstorage.b-cdn.net/782266dd-afeb-4ad6-b49d-cb966a16ce912023-09-14%2010-56-43.mp4
// Для того щоб зупинити сервер, тобто перервати процес, перебуваючи в терміналі, необхідно натиснути комбінацію клавіш:

//* Ctrl + C для користувачів Windows
// Control + C для користувачів MacOS і Linux

//todo Tests:
// У якому полі файлу package.json зберігаються npm-скрипти проєкту?

// aliases
// commands
//* scripts
// Result

//* Абсолютно точно! У файлі package.json npm-скрипти проєкту зберігаються у полі scripts.

// Як запустити скрипт з іменем doStuff з package.json?

// npm doStuff
//* npm run doStuff
// npm exec doStuff
// Result

//* Правильно! Для запуску скриптів використовується npm команда run та ім'я скрипта, що запускається. Отже, правильна 
// відповідь — npm run doStuff.

//? Встановлення пакетів

// Залежність (npm пакет) — це різноманітні утиліти та бібліотеки, що вирішують специфічне завдання. Пакети пишуть 
// самі розробники й діляться ними зі спільнотою. Такий підхід спрощує життя, бо не потрібно винаходити колесо, усі 
// колеса вже давно лежать на полицях реєстру й готові до використання.

// NPM складається з трьох основних компонентів:

// Реєстр пакетів (registry) — велика загальнодоступна база даних інструментів розробки (пакетів).
// Сайт npmjs.com — використовується для пошуку та ознайомлення з документацією пакетів.
// Інтерфейс командного рядка (CLI) — запускається з терміналу і надає набір команд для роботи з реєстром і пакетами. 
// Дозволяє створювати скрипти для запуску в терміналі.
// Додамо в проєкт бібліотеку validator.js для валідації рядків, наприклад, введення користувача в поля форми. На сайті 
// npmjs.com на сторінці будь-якої бібліотеки є інструкція зі встановлення та використання.

// Команда npm install [package-name] або її короткий псевдонім npm i [package-name] встановить бібліотеку як залежність проєкту.
// Виконуємо команду npm i validator у терміналі в папці проєкту.
// NPM завантажив validator і помістив його в node_modules — папку, в якій знаходяться всі зовнішні залежності.
// У файлі package.json з'явилася нова залежність в полі dependencies. Це означає, що validator версії 13.11.0 був встановлений 
// як залежність і готовий до роботи.
// Пакети постійно оновлюються, отже, твоя версія може відрізнятися.
// {
//   "name": "my-vite-project",
//   "private": true,
//   "version": "0.0.0",
//   "type": "module",
//   "scripts": {
//     "dev": "vite",
//     "build": "vite build",
//     "preview": "vite preview"
//   },
//   "devDependencies": {
//     "vite": "^4.4.5"
//   },
//   "dependencies": {
//     "validator": "^13.11.0"
//   }
// }
// Щоб отримати інтерфейс пакета в JavaScript коді, необхідно імпортувати його в будь-який JS-файл проєкту, наприклад у main.js, попередньо видаливши з нього весь код, який там був.

// // У файлі main.js
// import validator from "validator";

// console.log(
//   "Is mango@mail.com a valid email?: ",
//   validator.isEmail("mango@mail.com")
// ); // Is mango@mail.com a valid email?: true

// console.log(
//   "Is Mangodogmail.com a valid email?: ",
//   validator.isEmail("Mangodogmail.com")
// ); // Is mango@mail.com a valid email?: false
// Результатом імпорту бібліотеки validator.js буде об'єкт із методами. Ми детально розберемо синтаксис імпорту трохи пізніше.
// Запустивши сервер розробки командою npm run dev, у браузері в консолі ми побачимо повідомлення про результат валідації пошти.

//todo Test:

// Яка npm команда виконує встановлення пакета myPackage у проєкт?

//* npm install myPackage
// npm add myPackage
// npm download myPackage
// Result

//* Усе правильно! Для встановлення пакета myPackage у проєкт використовується команда npm install [package-name] або її короткий псевдонім npm i [package-name].

// Чи потрібно щось змінювати у файлі package.json після встановлення нового пакета?

// Так, записи про залежності не додаються автоматично
//* Ні, записи про залежності додаються автоматично
// Result

//* Правильно! Навіщо змінювати, якщо все це робиться автоматично!

//?  Видалення пакетів

// Припустимо, що ми вирішили перестати використовувати в проєкті бібліотеку validator.js.
// Крім того, що ми видалимо код, який використовує бібліотеку, необхідно видалити її як залежність проєкту.
// Ми можемо видалити будь-яку залежність командою npm uninstall [package-name] або її коротким псевдонімом npm r [package-name].
// Так само, як і в разі додавання залежності, після її видалення автоматично змінюється файл package.json.

// {
//   "name": "my-vite-project",
//   "private": true,
//   "version": "0.0.0",
//   "type": "module",
//   "scripts": {
//     "dev": "vite",
//     "build": "vite build",
//     "preview": "vite preview"
//   },
//   "devDependencies": {
//     "vite": "^4.4.5"
//   }
// }
// Після видалення залежності validator.js з файлу package.json зникла властивість dependencies, а в папці node_modules — папка validator.

//todo Tests:
// Яка команда npm видаляє пакет myPackage з проєкту?
// npm remove myPackage
//* npm uninstall myPackage
// npm delete myPackage
// Result
//* Абсолютно вірно! Команда npm uninstall myPackage видаляє пакет myPackage з проєкту.

// Які зміни відбуваються у файлі package.json після видалення пакета?
// Залишаються всі залежності, які були до видалення
//* Залишаються всі залежності, крім видаленого пакета
// Залишаються тільки видалені залежності
// Result 
//* Правильно! Після видалення пакета з файлу package.json залишаються всі залежності, крім видаленого пакета.

//? Типи залежностей

// Уяви торт. Для його приготування шефу, перш за все, потрібні продукти, адже саме вони увійдуть до складу торта. 
// Також будуть потрібні спеціальні інструменти, скажімо міксер, миска для тіста, лопатки тощо. А ще на кухні є столи і печі, 
// холодильники, тобто ті речі, що використовується для приготування будь-якої страви — це загальні інструменти, які є на кухні.
// Так само і з залежностями проєкту: деякі будуть використані у фінальному продукті, інші необхідні тільки на стадії розробки.
// Саме для цього команди npm install і npm uninstall мають два прапорці.
// --save — вказує, що додається залежність, яка увійде до фінального продукту. Пакет буде встановлений локально, в папку node_modules, і буде доданий запис у поле dependencies в package.json.
// --save-dev — вказує, що додається залежність розробки, яка не увійде до фінального продукту. Пакет буде встановлений локально, в папку node_modules, і буде доданий запис у поле devDependencies в package.json.
// Якщо не вибирати прапорець, за замовчуванням буде використаний --save.
// Видаляючи пакет, необхідно вказувати правильний прапорець, такий самий, що й для встановлення.
//todo  Test:
// Яка команда додасть пакет myDep як залежність розробки?

// npm i myDep --save
//* npm i myDep --save-dev
// npm i myDep --dev
// Result

//* Саме так! Правильна команда для додавання пакета myDep як залежності розробки — це npm i myDep --save-dev .

//!!!    Модульність коду

// ? Модульність коду

// / Концепція модулів як способу організації коду існувала давно. Зі збільшенням проєкту і його кодової бази, її намагаються розбити
// на файли, у кожному з яких описується окремий функціонал. Модульний код допомагає в організації, обслуговуванні, тестуванні 
// і, найголовніше, управлінні залежностями.
// Найважливіші переваги модулів:


//* Підтримка — добре розроблений модуль покликаний максимально зменшити залежність від інших частин коду. Використання модулів 
// дозволяє розширювати функціонал застосунку з мінімальним ризиком порушити його роботу в цілому. Оновлення одного модуля набагато 
// простіше, якщо модуль самодостатній.
//* Простір імен — змінні, що не входять в область видимості функції, є глобальними. Внаслідок цього, як правило, відбувається забруднення 
// простору імен, де повністю непов'язаний код розділяє глобальні змінні. Модулі дозволяють уникнути забруднення простору імен, створюючи 
// окрему область видимості для змінних.
//* Повторне використання — усі розробники копіювали готовий код у нові проєкти, змінюючи його під специфіку проєкту. Але це величезна трата часу. Набагато краще, коли є модуль, який можна повторно використовувати знову і знову, без необхідності знати що-небудь про оточення, в якому він використовується.

//? ECMAScript модулі

// ECMAScript Modules (ESM) — сучасний стандарт системи модулів JavaScript, який відповідає за організацію та уніфікований 
// підхід до імпорту та експорту даних між різними файлами в проєкті.
// Модуль — це JavaScript-файл із фрагментом коду, який можна використовувати багато разів. Модуль експортує певні об'єкти, 
// зробивши їх доступними для інших модулів.
// У прикладі нижче файл makeMessage.js оголошує та експортує функцію для створення повідомлення за іменем користувача.

// export default function makeMessage(username) {
// 	return `Welcome, ${username}!`;
// }

// Функцію, яку експортує модуль makeMessage.js, можна використовувати у будь-якому іншому файлі проєкту, наприклад, у index.js.

// import makeMessage from "./makeMessage";

// console.log(makeMessage("Jacob")); // "Welcom, Jacob!"

// Кожен JavaScript-файл зберігає код в унікальному контексті модуля, імпортує необхідні йому залежності та експортує все, що 
// інші модулі можуть імпортувати. Далі ми детально розглянемо синтаксис експорту/імпорту.

// З часом ECMAScript Modules (ESM) буде повністю підтримуватися браузерами нативно, без потреби додаткових інструментів. 
// Проте на даний момент браузерна підтримка ще не повністю реалізована, тому ESM часто використовується спільно з інструментами 
// для збірки модулів, такими як Vite, який дозволяє це робити без додаткової конфігурації.

//todo Test:

//  Що таке модуль?

// Будь-який файл налаштувань проєкту
//* Будь-який JavaScript-файл проєкту
// Тільки файли залежностей проєкту
// Result

//* Саме так! Модуль у JavaScript — це будь-який JavaScript-файл проєкту, який містить певний код і може бути 
// імпортований та використаний в інших JavaScript-файлах.

//? Експорт та імпорт за замовчуванням

// Основна ідея полягає в тому, що в одному модулі може бути лише один експорт за замовчуванням (default export). 
// Це значення вважається "головним" значенням модуля, коли його імпортують в інші частини коду.
// Операція експорту за замовчуванням реалізована конструкцією export default.

// export default exportedValue
// Де:

// export default — ключова фраза для експорту;
// exportedValue — значення, яке експортується.

// Ось так виглядає синтаксис для експорту значення за замовчуванням.

// const makeMessage = username => {
// 	return `Welcome, ${username}!`;
// };

// export default makeMessage;

// Операція імпорту за замовчуванням реалізована конструкцією import.

// import name from "..."

// Де:

// import і from — ключові фрази для імпорту;
// name — локальна змінна, в яку імпортується значення;
// **"..."** — відносний шлях до файлу модуля у вигляді рядка.


// У будь-якому іншому файлі проєкту можна імпортувати значення за замовчуванням.

// import makeMessage from "./makeMessage";

// console.log(makeMessage("Jacob")); // "Welcom, Jacob!"

// Зверни увагу, що ім'я, з яким імпортується значення за замовчуванням, може бути вибрано довільним чином.
// Використання експорту за замовчуванням зручне, коли тобі потрібно експортувати одне головне значення з модуля, 
// наприклад, основну функцію або об'єкт.

//todo Tests:
// Вибери правильний синтаксис експорту за замовчуванням для змінної username

// export username default
// username export default
// default export username
//* export default username
// Result

//* Абсолютно точно! Операція експорту за замовчуванням реалізована конструкцією export default, а далі значення, яке експортується.

// Вибери правильний синтаксис імпорту за замовчуванням

// from "..." import anyName
//* import anyName from "..."
// import { anyName } from "..."
// import anyName
// Result

//* Чудово! Правильний синтаксис імпорту за замовчуванням — це import anyName from "..."
// Де anyName — це локальна змінна, в яку імпортується значення, а "..." — відносний шлях до файлу модуля у вигляді рядка.

//? Іменовані експорт та імпорт

// Іменований експорт (named export) — це спосіб експортування одного або кількох значень з модуля під конкретними іменами.
// За допомогою іменованого експорту можна отримати доступ до будь-якого значення: змінної, функції або об'єкта тощо під
// певним ім'ям. Пізніше ці значення можна імпортувати в іншому файлі за допомогою цього самого імені.
// Операція іменованого експорту реалізована конструкцією з export.

// export exportedValue
// Де:

// export — ключове слово для експорту;
// exportedValue — значення, яке експортується.


// Ось так виглядає синтаксис для іменованого експорту.

// export const makeMessage = username => {
// 	return `Welcome, ${username}!`;
// };

// export const levels = ["easy", "medium", "hard"];

// Зверни увагу! Кількість іменованих експортів в одному модулі не обмежена, на відміну від експорту за замовчуванням, 
// який може бути тільки один.
// Операція іменованого імпорту реалізована конструкцією з import.

// import { name } from "..."

// Де:

// import — вказує на суть операції;
// from — на шлях до модуля з імпортованою сутністю;
// name — ім'я змінної, яке повинно збігатися з іменем експорту в модулі;
// "..." — шлях до файлу модуля у вигляді рядка.

// У будь-якому іншому файлі проєкту можна імпортувати конкретні елементи з іншого файлу (модуля), використовуючи їх імена 
// в конструкції іменованого імпорту.

// import { makeMessage, levels } from "./makeMessage";

// console.log(makeMessage("Jacob")); // "Welcom, Jacob!"
// console.log(levels); // ["easy", "medium", "hard"]

// Зверни увагу, що при імпорті ми вказуємо конкретні імена, які були використані при експорті. Це дозволяє точно вказати, 
// які значення ми хочемо імпортувати з модуля.
// Іменований імпорт використовується, коли модуль містить багато експортованих значень, і потрібно вибрати лише деякі. 
// Він працює тільки з іменованим експортом і не може імпортувати значення, експортоване за замовчуванням.

//todo  Tests:
// Вибери правильний синтаксис іменованого експорту змінної username

// export default username
//* export const username = "Mango"
// username export
// Result

//* Чудово! На відміну від експорту за замовчуванням (export default username) іменований експорт не має слова default і може 
// бути вже при оголошенні змінної, тобто ось так — export const username = "Mango".

// Вибери правильний синтаксис іменованого імпорту змінної username

//* import { username } from "..."
// import { anyName } from "..."
// import username from "..."
// Result

//* Правильно! Синтаксис іменованого імпорту змінної username — це import { username } from "...", де ім’я змінної у фігурних дужках.

//? Перейменування

// Rename export — це техніка, яка дозволяє імпортувати іменовані експортовані змінні, функції тощо з одного модуля до іншого, 
// змінюючи їм ім’я під час імпорту.
// Щоб задати нове ім'я під час імпорту з іншого модуля, використовується ключове слово as.

// import { name as newName } from '...'
// Наприклад:
//* Module myModule.js
// export const original = "Hello, World!";

// Your current module, for example app.js
// import { original as renamed } from './myModule.js';

// console.log(renamed); // "Hello, World!"
// У цьому прикладі ми імпортуємо змінну original з іншого модуля як renamed у нашому поточному модулі. Тепер ми можемо 
// використовувати renamed у нашому коді, і воно буде посилатися на значення, яке експортується з original.
// Коли використовувати перейменування? 
// У бібліотеках або в інших модулях імена можуть бути довгими, досить загальними або конфліктувати з іменами змінних у 
// твоєму поточному модулі. У цих випадках доцільно використовувати перейменування для зручності та уникнення конфліктів.

//todo Test:

//Вибери правильний синтаксис імпорту змінної A під ім'ям B?

// import B from "..."
// import { A to B } from "..."
//* import { A as B } from "..."
// import A as B from "..."
// Result

//* Усе правильно! import { A as B } from "..." — це правильний синтаксис перейменування змінної A в змінну В під час імпорту.

//? Імпорт простору імен

// Імпорт простору імен (namespace import) — це техніка імпортування всього вмісту модуля як об'єкта з іменем, що представляє простір імен цього модуля. Це означає, що всі іменовані експорти з модуля стають властивостями цього об'єкта. Це зручно, коли потрібно імпортувати багато різних функцій, змінних або класів з модуля, не обираючи їх по одному.

// Наприклад:

// // Module user.js
// export const name = "Mango";
// export const age = 26;
// export const email = "mango@mail.com";

// // Your current module
// import * as user from './myModule.js';

// console.log(user.name); // "Mango"
// console.log(user.age); // 26
// console.log(user.email ); // "mango@mail.com"

// У цьому прикладі ми імпортуємо всі іменовані експорти з модуля user.js як об'єкт user. Усі іменовані експорти стають 
// властивостями цього об'єкта. В результаті ми можемо звертатися до них через крапку.
// Імпорт простору імен дозволяє уникнути конфліктів імен між імпортованими об'єктами та іменами у твоєму поточному модулі. 
// Це особливо корисно, коли ти працюєш з бібліотеками або модулями, де є багато іменованих експортів.

//todo  Test:

// Вибери синтаксис імпорту простору імен усіх експортів модуля в об'єкт з ім'ям everything

// import everything as * from "..."
// import everything from "..."
//* import * as everything from "..."
// import * from "..."
// Result

//* Саме так! Виглядає довгеньким, але ти все правильно пам’ятаєш.