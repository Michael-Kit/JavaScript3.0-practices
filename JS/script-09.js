//!! Формат JSON
// Стандарт JSON
// JSON(JavaScript Object Notation) — сучасний текстовий формат зберігання й передачі структурованих даних у текстовій формі.
// Саме в цьому форматі дані будуть приходити і відправлятися на сервер, зберігатися в локальному сховищі тощо.
// Звичайний об'єктоподібний синтаксис JSON дуже зручний. Але JSON — це не об'єкт, а його рядкове відображення. Розгляньте приклад JSON файлу.

// Приклад JSON
// Це об'єкт, що містить різні типи даних: рядки, числа, масиви та інші об'єкти.
// {
//   "name": "Josh",
//   "weight": 175,
//   "age": 30,
//   "eyecolor": "brown",
//   "isHappy": true,
//   "cars": ["Chevy", "Honda"],
//   "favoriteBook": {
//     "title": "The Last Kingdom",
//     "author": "Bernard Cornwell",
//     "rating": 8.38
//   }
// }
// Синтаксис схожий на об'єкт, за винятком того, що:
// Ключі — це завжди рядки, обов'язково в подвійних лапках.
// Значення рядків — також обов'язково в подвійних лапках.
// Числа можуть бути цілими або десятковими, з десятковою крапкою або без неї, включаючи негативні.
// Числа та булеві значення true і false записуються так само, як у JavaScript.
// У JSON немає коми після останньої властивості об'єкта.
// Значення властивостей може бути спеціальним значенням null, але не може бути undefined.
// Функції не можна зберігати у JSON, оскільки JSON передбачений лише для даних, а не для методів обробки даних.
// JSON не підтримує коментарі, тому що це формат даних, а не код. Коментарі в JSON не допускаються.
// JSON не є JavaScript, але він дуже схожий на об'єкти JavaScript. Це дозволяє легко перетворювати об'єкти JavaScript у JSON і навпаки.
//todo Test:
// Вибери типи даних, які можна зберігати у JSON

//* Число
//* Рядок
// undefined
//* Масив
// Функція
//* null
// Result

//*  Чудово! У JSON зберігаються числа, рядки, масиви, а також спеціальне значення null.

// Прочитай приклад коду
// {
// 	username: "Jacob",
// 	age: 32,
// }

// Чи є код вище валідним JSON?

// Так
//* Ні
// Result

//* Ти дуже уважний/-а! JSON використовує подвійні лапки для ключів. У JSON також немає коми після останньої властивості об'єкта.

//? Перетворення у json

// Javascript і JSON чудово працюють разом, завдяки методам вбудованого класу JSON. Ці методи перетворюють JavaScript об'єкт у JSON і навпаки.
// Метод JSON.stringify(value) приймає значення і перетворює його у JSON. Значенням може бути число, буль, null, масив, об'єкт.
// Рядки — це вже валідний JSON, тому в їх перетворенні немає сенсу.

// const dog = {
//   name: "Mango",
//   age: 3,
//   isGoodBoy: true,
// };

// const json = JSON.stringify(dog);
// console.log(json); // '{"name":"Mango","age":3,"isGoodBoy":true}'

// Результат виклику JSON.stringify — це валідний JSON (рядок), який може бути збережений у вебсховище, базу даних або переданий мережею на сервер.
//todo  TEST:
// Який метод приводить дані до формату JSON?

// JSON.convert()
// JSON.toString()
// JSON.stringify()
// Result

// Саме так! Метод, який приводить дані до формату JSON, це JSON.stringify().

// Яким буде результат виклику JSON.stringify(32)?

// Число 32
//* Рядок “32”
// undefined
// Result

//* Абсолютно точно! JSON.stringify перетворює число 32 у відповідний рядок "32" у форматі JSON. Отже, результатом виклику JSON.stringify(32) буде рядок "32".

// Яким буде результат виклику JSON.stringify(true)?

// 1
//* Рядок “true”
// Буль true
// Result

//* JSON.stringify конвертує логічне значення true у відповідний рядок "true" у
// форматі JSON.Отже, результатом виклику JSON.stringify(true) буде рядок "true".

//?  Перетворення функцій

// Не всі JavaScript об'єкти можуть бути перетворені один в один у JSON. Наприклад,
// якщо в об'єкта є методи, то при перетворенні вони будуть проігноровані та не потраплять у JSON.

// const dog = {
//   name: "Mango",
//   age: 3,
//   isGoodBoy: true,
//   bark() {
//     console.log("Woof!");
//   },
// };

// const json = JSON.stringify(dog);
// console.log(json); // '{"name":"Mango","age":3,"isGoodBoy":true}'

// Також при спробі перетворити функцію у JSON результатом буде undefined.

// const json = JSON.stringify(() => console.log("Well, this is awkward"));
// console.log(json); // undefined

//todo  Test :
// Що буде з методами об'єкта при спробі перетворити його у json?

//* Вони будуть проігноровані
// Буде помилка перетворення
// Вони перетворяться на рядок
// Result

//* Усе правильно — при перетворенні у JSON методи об'єкта будуть проігноровані.

//?Парсинг із json

// Щоб отримати з JSON валідне JavaScript значення, його необхідно розпарсити(parse).
// Це операція зворотня перетворенню JavaScript об'єкта в json за допомогою методу
// JSON.stringify(value)
// Метод JSON.parse(value) приймає json, тобто рядок, і перетворює його у JavaScript
// дані.

// console.log(JSON.parse("5")); // 5
// console.log(JSON.parse("false")); // false
// console.log(JSON.parse("null")); // null

// Якщо json описує складний тип даних, наприклад об'єкт, то в результаті отримаємо валідний об'єкт, з яким можна працювати звичайним чином.

// const json = '{"name":"Mango","age":3,"isGoodBoy":true}';

// const dog = JSON.parse(json);
// console.log(dog); // {name: "Mango", age: 3, isGoodBoy: true}
// console.log(dog.name); // "Mango"
//todo  Test:
// Який метод парсить дані з json?

// JSON.toParse
// JSON.stringify
//* JSON.parse
// Result

//* Це правильна відповідь! Метод JSON.parse() парсить дані з JSON.

//?  Обробка помилок
// Якщо методу JSON.parse передати невалідний JSON, він згенерує помилку.Як результат,
// увесь скрипт впаде, тобто припинить своє виконання, і весь код після місця помилки
// не виконається.
// До такого сценарію призведе, наприклад, парсинг рядка.
// Рядок із символами — це невалідний JSON, адже він не може бути перетворений у валідне
// JavaScript значення.
// const data = JSON.parse("Hello, world!"); // Error
// console.log("❌ You won't see this log");
// const data = JSON.parse("Well, this is awkward");
// console.log("❌ You won't see this log");



// Помилка буде і при спробі парсингу невалідного об’єкта, який, наприклад,
// може прийти з бекенду.У прикладі у властивості username бракує подвійних лапок.
// Це невалідний JSON, адже ключі об'єкта мають бути в подвійних лапках.
// Якщо спробувати його розпарсити, то буде згенеровано помилку.
// const data = JSON.parse('{username: "Mango"}'); // Error
// console.log("❌ You won't see this log");

//*  Рішення
// Для уникнення цього використовується конструкція try...catch, яка дозволяє «ловити»
// й обробляти помилки виконання скрипта.

// try {
  // Code that may throw a runtime error
// } catch (error) {
  // Error handling
// }

// Спочатку виконується код всередині блоку try.
// Якщо помилки відсутні, блок catch ігнорується й управління передається далі.
// Якщо в блоці try сталася помилка, його виконання зупиняється та інтерпретатор
// переходить до блоку catch.
// Використовуючи конструкцію try...catch, можна обробити цей виняток таким чином,
// щоб скрипт за межами цієї конструкції продовжив працювати, навіть у разі помилки.

// try {
//   const data = JSON.parse("Well, this is awkward");
// } catch (error) {
//   console.log(error.name); // "SyntaxError"
//   console.log(error.message); // Unexpected token W in JSON at position 0
// }

// console.log("✅ This is fine, we handled parsing error in try...catch");
// У цьому прикладі, якщо сталася помилка під час парсингу, вона буде оброблена в
// блоці catch,
// а скрипт продовжить виконання, вивівши повідомлення "✅ This is fine, we handled
// parsing error in try...catch".
// Змінна error — це об'єкт помилки з інформацією про те, що сталося.
// У цього об'єкта є кілька корисних властивостей:
// name — тип помилки. Для помилки парсингу — це SyntaxError.
// message — повідомлення про деталі помилки.
// stack — стек викликів функцій на момент помилки. Використовується для налагодження.
//todo Test:
// Навіщо використовувати try...catch під час парсингу json?

// Щоб правильно розпарсити дані з формату json
//* Щоб у разі помилки парсингу скрипт не впав
// Щоб можна було розпарсити будь-який тип даних
// Result

//* Звісно, так і є! Використовуючи try...catch, можна визначити та обробити помилки парсингу JSON, щоб скрипт продовжив працювати.

// Коли виконується блок catch?

// Завжди після завершення виконання коду в блоці try
// Тільки у випадку, коли в блоці try не буде помилки
//* Тільки у випадку, коли в блоці try є помилка
// Result

//* Усе правильно — блок catch виконується тільки у випадку, коли в блоці try
// виникає помилка.

//? Детальніше про помилки

// У JavaScript код виконується не одразу.
// Для початку інтерпретатору потрібно прочитати код і дізнатися, чи можливо його
// взагалі виконати.

// Фаза інтерпретації, або оцінки(compile time, evaluation time) — підготовка перед
// виконанням коду: інтерпретатор знаходить синтаксичні помилки, помилки типізації тощо.
// Отже, код ще не виконується, лише оцінюється.
// Якщо ця фаза пройшла успішно, це щонайменше означає, що в коді відсутні синтаксичні
// помилки і його можна запустити для виконання.
// Фаза виконання(runtime) — скрипт починає виконуватися: виконуються інструкції
// викликів функцій і оцінювання виразів, відбувається пошук необхідних ідентифікаторів
// у відповідних областях видимості тощо.
// Якщо ця фаза проходить успішно, це свідчить про те, що скрипт написаний без явних
// помилок і виконав свою роботу.На цій фазі можуть бути помилки, пов'язані з відсутніми
// властивостями та змінними, перетворенням типів тощо, тобто щось, що відбувається
// тільки під час виконання коду.
// Спробуй виконати наступний код.
    
// console.log('This message will not appear in the console');

// cos value = 5;
// У ньому навмисно зроблена помилка.Замість const намагаємося оголосити змінну value
// ключовим словом cos.На фазі оцінки буде виявлена синтаксична помилка.Фаза виконання
// навіть не запуститься.У консолі ми одразу побачимо повідомлення про помилку.

// Конструкція try...catch ловить тільки помилки, які виникли під час виконання коду
// (runtime errors).Це означає, що код має бути синтаксично правильним, інакше фаза
// виконання просто не запуститься.Помилки, які виникають під час фази оцінювання,
//     називаються помилками парсингу.

    //!! Вебсховище
// //? Сookie
// Скільки разів тобі зустрічалося спливаюче вікно на вебсайті з написом:
// Цей вебсайт використовує файли cookie для зберігання вашої інформації.
// Скоріш за все, так часто, що можна збитися з рахунку!
// Свого часу вебсайти використовували протокол HTTP без збереження стану.Це означало,
// що вони не могли зберігати інформацію, пов’язану з користувачем, таку як
// ідентифікатор сеансу користувача, ім’я користувача, наповнення кошика товарів тощо,
// у веббраузері.
// З розвитком інтернету та його популярністю вебсайти почали зберігати інформацію,
// пов’язану з користувачем, у самому браузері.Це допомогло розрізняти тип користувача,
// який взаємодіє з їхнім вебсайтом, і забезпечити персоналізований досвід для
// користувача.
// Так з’явилися cookie(кукі).Вони надали механізм для зберігання невеликих фрагментів
// текстових даних клієнта або сервера у браузері як пари ключ - значення.Сookie також
// мають позначку часу закінчення терміну їх дії, після чого автоматично видаляються
// браузером.
// Браузер і сервер можуть установлювати та отримувати cookie з браузера користувача.
// Крім того, cookie можуть автоматично надсилатися разом із кожним HTTP - запитом на
// сервер.У результаті сервер може легко розпізнати інформацію користувача з кожним
// HTTP - запитом, який зробив користувач.
// Сookie використовуються й досі, але взаємодія з ними часто зводиться до встановлення
// та читання їх значень на сервері.Зазвичай це робиться за допомогою різних бібліотек,
// щоб спростити весь процес.
// Фронтенд рідко взаємодіє із вмістом cookie безпосередньо, оскільки вони можуть бути
// дещо обмеженими у використанні та мати обмежену ємність для зберігання даних.Щоб
// вирішити цю проблему, сучасні браузери мають власні механізми зберігання, такі як
// локальне сховище та сховище сеансів.

//? Web Storage API
// Cookie розв'язують проблему збереження інформації на стороні користувача під час
// взаємодії з вебсайтами.Водночас вони мають деякі обмеження.
// По - перше, їхні можливості обмежуються зберіганням даних розміром лише до кількох
// кілобайт.З ростом складності клієнтських програм виникла потреба зберігати більш
// об'ємні та складні дані прямо у браузері.
// З появою HTML5 на вебсайтах з'явилося API зберігання даних у браузері для ефективного
// управління інформацією на стороні користувача.Таким чином, будь - який JavaScript -
// код, що запускається у браузері, може легко отримати доступ до цих API.Основна
// відмінність полягає в тому, що ці механізми надавали більший об'єм для зберігання
// даних і можуть бути доступні лише для JavaScript, що виконувався на боці клієнта.
// Вебсховище — це механізм у веббраузерах, який дозволяє вебдодаткам зберігати та
// отримувати дані на стороні клієнта, тобто на комп'ютері користувача. Щоразу, коли
// ти змінюєш тему кольорів між світлою і темною, переглядаєш відео, додаєш товар у
// кошик, відкриваєш або закриваєш сайдбар, популярні вебзастосунки можуть
// запам'ятовувати стан інтерфейсу і в наступному відвідуванні відновлювати його.
// Вебсховище не зберігає паролі, номери банківських карт та іншу конфіденційну
// інформацію.Якщо шкідливий скрипт отримає доступ до вебсторінки, він без проблем
// зможе прочитати ці дані.
// Вебсховище складається з локального сховища та сховища сеансів.
// Локальне сховище(Local Storage): унікальне для кожного вебдодатку і буде
// однаковим на кількох вкладках, де вебдодаток відкритий.Дані в локальному сховищі
// не видаляються, навіть після закриття браузера або вимкнення комп'ютера. Щоб їх
// видалити, потрібно використовувати JavaScript.Доступ до даних у локальному сховищі
// можливий з будь - якої вкладки або вікна браузера, пов'язаної з доменом, який створив
// дані.
// Сховище сесії(Session Storage): на відміну від локального сховища, дані у сховищі
// сесії зберігаються лише протягом одної сесії браузера.Якщо користувач закриє вкладку
// або браузер, дані будуть видалені.Сховище сесії зручне для зберігання тимчасових
// даних або станів, які не повинні зберігатися довгий час.

//? Інструменти розробника

// Давай розглянемо, де у браузері знаходяться інструменти розробника для взаємодії з локальним сховищем і сховищем сеансу.

// Відкрий інструменти розробника у браузері та перейди на вкладку Application (укр. Додаток).
// У розділі Storage(укр.Пам’ять) **** ти знайдеш розділи під назвою Local Storage(укр.Локальна пам’ять)
// та Session Storage(укр. **** Пам’ять сеансу).
// Натисни на них, щоб побачити все, що зберігається в сховищі сеансу або локальному сховищі для цього вебсайту.

//? Локальне сховище
// Дані в локальному сховищі зберігаються у JSON форматі під певним ключем.Цей ключ може бути тільки рядком, і значенням
// виступає будь - що, що дозволяється JSON форматом.
// Локальне сховище може зберігати дані розміром від 5 Мб до 10 Мб.Точний обсяг пам’яті залежить від реалізації кожного б
// раузера, але це значно більше, ніж 4 Кб пам’яті, яку пропонують cookie.
// Дані в локальному сховищі не мають терміну зберігання за замовчуванням.Вони видаляються, лише якщо ти вручну видалиш ці
// дані з локального сховища безпосередньо, через налаштування браузера або за допомогою коду JavaScript.Це означає, що дані
// в локальному сховищі зберігаються навіть після закриття певної вкладки або вікна браузера.У кожного сайту своє окреме локальне
// сховище, тому збережені дані між сайтами не перетинаються.
// Доступ до локального сховища можна отримати в об’єкті window:

// console.log(window.localStorage);
// // Storage {length: 0}
// Це поверне довжину локального сховища разом з об’єктом, що представляє дані, які зараз присутні всередині.
// Оскільки спочатку він порожній, довжина дорівнює 0.
// Можна також отримати прямий доступ до об’єкта localStorage, адже за замовчуванням пошук відбувається на об’єкті window.
// console.log(localStorage);
// // Storage {length: 0}
// Завдяки тому, що дані в локальному сховищі не мають терміну зберігання за замовчуванням, цей тип сховища
// має цілу низку застосувань.Це всі ті сценарії, коли потрібно зберігати деякі глобальні дані, до яких часто звертаються у програмі.
// Наприклад, зміна теми кольорів між світлою і темною, перегляд відео, додавання товару в кошик, відкривання або закривання
// сайдбара, бажаний спосіб оплати користувача, адреси доставки за замовчуванням тощо, увесь цей стан інтерфейсу можливо зберегти
// і в наступному відвідуванні відновити його.

// todo Testb:

// Що таке localStorage в контексті веброзробки?

// Бібліотека для асинхронного завантаження ресурсів.
// Спеціальний клас для роботи з локальними файлами.
//* Механізм для зберігання даних у браузері клієнта.
// Result

//* Саме так! localStorage — це механізм для зберігання даних у браузері клієнта в режимі локального сховища.

// Чи зберігає localStorage дані під час перезавантаження сторінки?

// Так
// Ні
// Result

// Маєш рацію! Дані, збережені в localStorage, залишаються доступними у браузері клієнта, поки користувач не видалить їх вручну або поки не буде очищено кеш браузера.

// Якщо ти використовуєш localStorage на одному вебсайті і потім переходиш на інший вебсайт, чи буде доступ до даних, збережених у localStorage на першому вебсайті?

// Так, дані доступні на всіх вебсайтах.
//* Ні, дані доступні тільки на тому вебсайті, де вони були збережені.
// Result

//* Саме так! У кожного сайту своє окреме локальне сховище, тому збережені дані між сайтами не перетинаються.

//?  Додавання даних

// Давай додамо пару ключ-значення до локального сховища за допомогою методу setItem(key, value), доступного в об’єкті localStorage:
// localStorage.setItem("ui-theme", "light");
// Це встановить новий запис у сховищі з ключем "ui-theme" і значенням "light".Якщо ти просто викличеш об’єкт localStorage
// зараз, то побачиш збережені дані.

// console.log(localStorage); // Storage {ui-theme: "light", length: 1}

// Ти також побачиш це у браузері в розділі «Local Storage» в інструментах розробника:
// А що як у сховищі вже існував запис із ключем "ui-theme"?
// Виклик методу setItem(key, value) перезапише його значення.

//todo  Testb:
// Які аргументи приймає метод localStorage.setItem?

// Номер індексу та значення для зберігання
//* Ключ і значення для зберігання
// Тільки значення
// Result

//* Абсолютно точно! Метод localStorage.setItem приймає два аргументи: ключ і значення для зберігання.

// Що робить метод localStorage.setItem(key, value) у браузері?

// Отримує значення за ключем з localStorage
//* Встановлює значення для ключа в localStorage
// Видаляє ключ та його значення з localStorage
// Result

//* Варто запам’ятати, що метод localStorage.setItem(key, value) встановлює новий запис у сховищі.

// Якщо викликати localStorage.setItem("userData", "new_data");, і ключ "userData" вже існує в localStorage, що станеться ?

//* Значення для ключа "userData" буде оновлено на "new_data"
// Нічого не станеться, існуюче значення буде збережено
// Буде помилка запису
// Result

//* Супер! Якщо ключ "userData" вже існує в localStorage, то виклик localStorage.setItem("userData", "new_data");
// оновить значення для цього ключа на "new_data"

//? Додавання складних даних

// У вебсховище не записують методи об'єктів або функції, тільки дані, які підтримує
// JSON формат.
// Технічно у вебсховище можна записати тільки рядки.Але це не проблема, якщо
// використовувати методи класу JSON для перетворення складних типів.
// Якщо необхідно зберегти щось, окрім рядка, наприклад, масив або об'єкт,
// необхідно перетворити їх у рядок методом JSON.stringify().

// const settings = {
//   theme: "dark",
//   isAuthenticated: true,
//   options: [1, 2, 3],
// };

// localStorage.setItem("settings", JSON.stringify(settings));
// Тепер дані мають з’явитися в локальному сховищі браузера:

//todo  Tests:
// Які типи даних можна зберігати в локальному сховищі?

// Тільки об'єкти
//* Тільки рядки
// Будь-які типи даних
// Result

//* Точнісінько так! У вебсховище можна записати тільки рядки.

// Що потрібно зробити зі складними типами даних перед записом у локальне сховище?

// Привести їх до об'єкта
//* Привести їх до рядка
// Додати метод toString
// Result

//* Це логічно, чи не так? Якщо у вебсховище можна записати тільки рядки, перед записом у локальне сховище варто привести складні типи даних до рядка.

//? Отримання даних

// Метод getItem(key) дозволяє зчитати зі сховища запис із ключем key і повертає його
// значення у JSON форматі.

// const savedTheme = localStorage.getItem("ui-theme");
// console.log(savedTheme); // "light"

// Якщо у сховищі відсутній запис з таким ключем, метод повертає null.

// const savedItem = localStorage.getItem("key-that-does-not-exist");
// console.log(savedItem); // null

// Якщо значення є примітивним типом, немає потреби його парсити.
// В іншому випадку, якщо це масив або об'єкт, необхідно розпарсити значення методом

// JSON.parse(), щоб отримати валідні дані.

// const settings = {
//   theme: "dark",
//   isAuthenticated: true,
//   options: [1, 2, 3],
// };
// localStorage.setItem("settings", JSON.stringify(settings));

// const savedSettings = localStorage.getItem("settings");
// console.log(savedSettings); // A string

// const parsedSettings = JSON.parse(savedSettings);
// console.log(parsedSettings); // Settings object

// У змінній savedSettings буде рядок, що представляє об'єкт, тому ми розпарсюємо це
// значення, і у змінній parsedSettings отримуємо повноцінний об'єкт із властивостями.
//todo  Tests:
// Як отримати значення з localStorage за ключем "username"?

// localStorage.access("username")
// localStorage.getData("username")
//* localStorage.getItem("username")
// Result

//* Абсолютно точно! Для отримання значення з localStorage за ключем "username" слід використовувати
// метод localStorage.getItem("username")

// Що повертає метод localStorage.getItem("key"), якщо ключ "key" не існує в localStorage?

//* null
// undefined
// false
// Result

//* Ти все правильно пам’ятаєш: якщо у сховищі відсутній запис з таким ключем, метод повертає null.

// Який тип даних ти отримаєш із localStorage.getItem("age"), якщо раніше ти зберігав/-ла число 25 під ключем "age"?

//* Рядок (string)
// Число (number)
// Булеве значення (boolean)
// Result

//* Правильна відповідь! Локальне сховище зберігає всі дані у форматі рядка, тому виклик localStorage.getItem("age")
// поверне рядок.

//? Видалення даних

// Метод removeItem(key) видаляє зі сховища існуючий запис з ключем key. В результаті своєї роботи він не повертає значення.

// localStorage.setItem("ui-theme", "dark");
// console.log(localStorage.getItem("ui-theme")); // "dark"

// localStorage.removeItem("ui-theme");
// console.log(localStorage.getItem("ui-theme")); // null

// Якщо ти хочеш повністю очистити сховище, потрібно викликати метод clear().

// localStorage.setItem("ui-theme", "light");
// localStorage.setItem("notif-level", "mute");

// console.log(localStorage);
// Storage {notif-level: 'mute', ui-theme: 'light', length: 2}

// localStorage.clear();
// console.log(localStorage); // Storage {length: 0}

// Операція повного очищення сховища є ризикованою.Вона може порушити записи, створені іншими розробниками проєкту.
// Краще видаляти лише ті записи, які дійсно не потрібні, не покладаючись на повну очистку даних сховища.
//todo Tests:
// Який аргумент приймає метод localStorage.removeItem?

// Індекс значення, яке треба видалити
//* Ключ елемента, який треба видалити
// Значення елемента, яке треба видалити
// Result

//* Звісно! Метод localStorage.removeItem приймає аргументом ключ елемента, який потрібно видалити з localStorage.

// Як можна очистити всі дані в localStorage?

//* Використовуючи localStorage.clear()
// Викликаючи localStorage.removeAll()
// Встановивши всім ключам і значенням null
// Result

//* Чудово! Для очищення всіх даних у localStorage використовується метод localStorage.clear().

//!  Сховище сесії
// Сховище сесії зберігає дані лише доти, поки відкрита вкладка браузера.

// Це означає, що кожного разу, коли відкривається нова вкладка або нове вікно браузера, створюється нове сховище сесії.
// Отже, будь - які дані, які зберігаються в сховищі сесії, автоматично видаляються, коли користувач закриває цю вкладку / вікно.
// Набір методів та їхній функціонал ідентичні методам роботи з локальним сховищем.

// Єдиний виняток — звертаємося до них через об'єкт sessionStorage, а не localStorage.

// console.log(window.sessionStorage); // Storage {length: 0}
// Методом setItem(key, value) можна записувати як рядки, так і складні типи даних.
// sessionStorage.setItem("user-id", "123");
// sessionStorage.setItem(
//   "tickets",
//   JSON.stringify({ from: "Lviv", to: "Kyiv", quantity: 2 })
// );
// console.log(sessionStorage);
// Storage {user-id: '123', tickets: '{"from":"Lviv","to":"Kyiv","quantity":2}', length: 2}

// Методом getItem(key) можна читати записи, використовуючи збережений ключ.
// const userId = sessionStorage.getItem("user-id");
// console.log(userId); // "123"

// const tickets = JSON.parse(sessionStorage.getItem("tickets"));
// console.log(tickets); // { from: "Lviv", to: "Kyiv", quantity: 2 }
// І звісно, видаляти елементи за ключем і очищати сховище цілком методами removeItem(key) і clear() відповідно.

// sessionStorage.removeItem("tickets");
// console.log(sessionStorage); // Storage {user-id: '123', length: 1}

// sessionStorage.clear();
// console.log(sessionStorage); // Storage {length: 0}

// Оскільки дані в сховищі сеансу зберігаються лише на вкладці браузера, існує кілька унікальних випадків використання
// сховища сеансу.

// Зберігання сеансів можна використовувати в багатоетапних процесах: бронювання авіаквитків, готелів, квитків у кіно,
// поїздів тощо.Можна зберігати деталі попередніх кроків у сховищі сеансу браузера, щоб попередньо заповнити ці форми або введені дані.
// Ще одним прикладом можуть бути вебсайти для ведення блогів, інформаційні бюлетені, навчальні вебсайти тощо.
// Такі сторінки мають безліч відвідувачів, які читають вміст, не створюючи облікового запису.У таких сценаріях можна
// попросити відвідувача створити обліковий запис.Щоразу, коли він чи вона читає допис у блозі чи статтю на іншій вкладці.
// Це може бути чудовим способом запропонувати своїм користувачам неблокуючий досвід і водночас ефективно перетворити їх на
// зареєстрованих користувачів.

//!!  Кейс: Форма з повідомленням

// Створимо форму для введення повідомлення.

// <form class="feedback-form">
//   <textarea name="message"></textarea>
//   <button type="submit">Send feedback</button>
// </form>

// Під час сабміту форми будемо виводити в консоль значення текстового поля та очищати форму.

// const form = document.querySelector(".feedback-form");

// form.addEventListener("submit", evt => {
//   evt.preventDefault();
// 	console.log(evt.target.elements.message.value);
//   form.reset();
// });

//* Проблема
// Якщо користувач ввів повідомлення в текстове поле і перезавантажив сторінку, не надіславши форму, під час перезавантаження
// сторінки введене повідомлення пропадає.

//* Рішення
// Зробимо так, щоб при перезавантаженні сторінки зберігалося введене повідомлення.
// Для цього використовуємо локальне сховище, щоб зберегти поточне значення текстового поля під час введення.

// const form = document.querySelector(".feedback-form");
// const localStorageKey = "goit-example-message";

// form.addEventListener("input", (evt) => {
//   localStorage.setItem(localStorageKey, evt.target.value);
// });

// form.addEventListener("submit", (evt) => {
//   evt.preventDefault();
// 	console.log(evt.target.elements.message.value);
//   form.reset();
// });
// Щоразу, коли змінюється значення поля, тобто відбувається подія "input", ми:
// використовуємо делегування подій;
// ловимо подію на формі;
// використовуємо властивість target для запису поточного значення поля в локальне сховище.

// Під час сабміту форми будемо очищати збережене значення методом removeItem.

// const form = document.querySelector(".feedback-form");
// const localStorageKey = "goit-example-message";

// form.addEventListener("input", (evt) => {
//   localStorage.setItem(localStorageKey, evt.target.value);
// });

// form.addEventListener("submit", (evt) => {
//   evt.preventDefault();
// 	console.log(evt.target.elements.message.value);
//   localStorage.removeItem(localStorageKey);
//   form.reset();
// });
// Останнім кроком необхідно додати код читання збереженого повідомлення з локального сховища і встановлення 
// його початковим значенням для текстового поля під час завантаження сторінки.

// const form = document.querySelector(".feedback-form");
// const textarea = form.elements.message;
// const localStorageKey = "goit-example-message";

// textarea.value = localStorage.getItem(localStorageKey) ?? "";

// form.addEventListener("input", (evt) => {
//   localStorage.setItem(localStorageKey, evt.target.value);
// });

// form.addEventListener("submit", (evt) => {
//   evt.preventDefault();
// 	console.log(evt.target.elements.message.value);
//   localStorage.removeItem(localStorageKey);
//   form.reset();
// });

// Змінюючи значення текстового поля і перезавантажуючи сторінку, можна побачити той самий текст, хоча нічого ще не вводили.





