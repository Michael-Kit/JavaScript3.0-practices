//!!!!!         HTTP-запити

//* Сервер — це комп’ютер із спеціальним програмним забезпеченням, який приймає та обробляє запити від інших пристроїв у мережі.

//* Бекенд — це програма, що працює на сервері, яка:

// Приймає вхідні HTTP-запити.
// Обробляє дані та виконує необхідні дії.
// Надсилає відповідь клієнту у вигляді даних (наприклад, у форматі JSON).

//* API (інтерфейс прикладного програмування) — набір чітко визначених правил, які визначають, що можна попросити програму зробити 
// і що буде в результаті.

//* REST API — це бекенд, побудований за принципами REST (Representational State Transfer). Ця архітектура визначає:

// Як називаються та адресуються ресурси.
// Як клієнт може взаємодіяти з ними через HTTP-запити.
// REST API виконує роль посередника між вебзастосунком і базою даних:

// Клієнт надсилає HTTP-запит.
// Сервер обробляє його та повертає JSON-відповідь, а не HTML-сторінку.
// REST API мають єдину логіку роботи, тому після розуміння принципів їх використання залишається лише читати документацію конкретного 
// бекенду. Це універсальний підхід, що дозволяє легко працювати з різними сервісами.

// Шлях до ресурсу

// Запити на бекенд повинні містити шлях до ресурсу, над яким виконується операція. Доступні шляхи (ендпоінти) описуються в документації 
// бекенду.
//* Ендпоінти (англ. endpoints) у вебсервісах та API — це конкретні URL-адреси, через які можна отримати доступ до певних функцій або 
// ресурсів сервера. Вони дозволяють:

// Отримувати дані.
// Надсилати нові дані.
// Оновлювати або видаляти існуючі записи.


// Давай розберемо це на прикладі JSONPlaceholder API. Це публічний REST API, який надає тестові дані.

// https://jsonplaceholder.typicode.com/users



// Цей шлях є ієрархічним та описовим, навіть якщо ми ніколи раніше його не бачили. Він складається з двох основних частин:
// 
// https://jsonplaceholder.typicode.com — базовий URL, точка входу в API.
// /users — ресурс, до якого ми звертаємося (у цьому випадку список користувачів).


// Як перевірити відповідь API?

// Скопіюй цей шлях та встав у адресний рядок браузера.
// Браузер виконає HTTP-запит.
// У відповідь прийде JSON-об'єкт із даними (замість HTML-сторінки).

// Таким чином, REST API працює як вебсайт, але повертає не сторінки, а структуровані дані у форматі JSON (див. схему).

//? Fetch API

// Fetch API — це вбудований у браузер інтерфейс, доступний через об'єкт window. Він дозволяє відправляти HTTP-запити на сервер і 
// обробляти відповіді.

// Метод fetch() забезпечує сучасний підхід до роботи з мережею та побудований на промісах.

// fetch(url, options)
// url — шлях до ресурсу на сервері (обов’язковий параметр).
// options — об’єкт із додатковими налаштуваннями запиту (наприклад, метод, заголовки, тіло тощо).

// JSONPlaceholder API — це тестовий REST API, який містить колекції фіктивних даних, наприклад список користувачів (/users).

// fetch("https://jsonplaceholder.typicode.com/users")
//   .then(response => {
    // Response handling
//   })
//   .then(data => {
    // Data handling
//   })
//   .catch(error => {
    // Error handling
//   });

// Як працює цей код?

// fetch() відправляє запит на сервер і повертає проміс.
// then(response => {...}) виконується, коли відповідь отримано.
// then(data => {...}) обробляє отримані дані.
// catch(error => {...}) виконується у разі помилки.

// todo Test

// Що повертає виклик функції fetch?
// Дані з бекенда
//* Проміс
// undefined
// Result

//* Чудово! Це дійсно так.

//? Вкладка Network

// Вкладка Network (укр. “Мережа”) в інструментах розробника дозволяє переглядати всі HTTP-запити, що виконуються на сторінці. 
// Вона корисна для перевірки деталей запитів до бекенду.
// Як переглянути запити в Network?

// Відкрий вкладку Network в інструментах розробника (Chrome: F12 або Ctrl + Shift + I).
// Обери фільтр XHR або Fetch/XHR, щоб бачити лише асинхронні HTTP/HTTPS-запити (fetch, XMLHttpRequest).
// Виконай код із fetch() або запусти скрипт, що робить HTTP-запит.
// У списку з’явиться запит — натисни на нього, щоб переглянути детальну інформацію.
// Відкрий відповідні підвкладки:
// Headers (укр. “Заголовки”) — показує всі відправлені заголовки та параметри.
// Preview (укр. “Попередній перегляд”) — показує зручне відображення відповіді сервера.
// Response (укр. “Відповідь”) — показує сирі дані, отримані від сервера.

// Чому це корисно?

// Дозволяє відстежувати всі запити вебсторінки.
// Дає змогу перевірити, чи правильно сформований запит.
// Допомагає виявляти помилки в мережевих запитах.

// Використання вкладки Network — один із основних інструментів налагодження вебзапитів у браузері.

//? Коди відповідей

// На запит клієнта сервер відправляє відповідь, яка містить код стану, щоб інформувати клієнта про результат операції.
// Код відповіді можна подивитися на вкладці Network у полі Status Code.
// Коди діляться на групи залежно від того, з якої цифри починається код помилки.

// 1XX — мають інформаційне призначення
// 2XX — коди успішного проведення операції
// 3XX — описують усе, що пов'язано з перенаправленням (redirect)
// 4XX — вказують на помилки з боку клієнта
// 5XX — вказують на помилки з боку сервера

// Немає потреби пам'ятати всі коди з кожної групи, достатньо знати найпоширеніші. Решту завжди можна подивитися в довіднику HTTP-кодів.

// 200 (OK) — стандартна відповідь для успішних HTTP-запитів.
// 201 (Created) — стандартна відповідь для HTTP-запиту, який привів до успішного створення ресурсу.
// 400 (Bad Request) — запит не може бути оброблений через неправильний синтаксис запиту або іншу помилку клієнта.
// 401 (Unauthorized) — для доступу до ресурсу вимагається авторизація.
// 403 (Forbidden) — у клієнта немає дозволу на доступ до цього ресурсу.
// 404 (Not Found) — у цей час ресурс не знайдений. Можливо, він був видалений або ще не існує.
// 500 (Internal Server Error) — загальна відповідь на непередбачений збій сервера, якщо відсутня конкретніша інформація.

// todo Test

// Вибери код відповіді, який відповідає успішному запиту

//*200
// 404
// 500
// Result

//* І це правильна відповідь! Успішний запит зазвичай відповідає статусному коду 200.

// todo Test frim Mentor видає помилки то його переписано

// function fetchData(statusCode) {
//   return fetch(`https://httpstat.us/${statusCode}`).then(response => {
//     if (response.ok) {
//       return response.json();
//     } else {
//       throw new Error(`HTTP error! status: ${response.status}`);
//     }
//   });
// }

// fetchData(200)
//   .then(result => console.log(result))
//   .catch(error => console.log(error.message));
// fetchData(404)
//   .then(result => console.log(result))
//   .catch(error => console.log(error.message));
// fetchData(500)
//   .then(result => console.log(result))
//   .catch(error => console.log(error.message));

// function fetchData(statusCode) {
//   return fetch(`https://httpbin.org/status/${statusCode}`)
//     .then(response => {
//       if (response.ok) {
//         console.log(`Дані для статусу ${statusCode}`);
//       } else {
//         throw new Error(`HTTP error! status: ${response.status}`);
//       }
//     })
//     .catch(error => console.log(error.message));
// }

// fetchData(200);   // ✅ буде успішним
// fetchData(404);   // ❌ буде помилка
// fetchData(500);   // ❌ буде помилка

// Варіанти відповіді:
// Дані для статусу 200, дані для 404, дані для 500 - :flag-ua:;    
//* Дані для статусу 200, помилка для 404, помилка для 500 - :blue_heart:;   
// Помилка для статусу 200, помилка для 404, помилка для 500 - :yellow_heart:;  
// undefined - :heart_on_fire:

//? Перевірка відповіді

// Метод fetch() повертає проміс, значенням якого є об'єкт Response. Це службовий об'єкт, що містить інформацію про стан 
// відповіді сервера та методи для обробки отриманих даних.

// Залежно від типу контенту використовуються різні методи для перетворення даних у зручний формат:

// json() — парсить відповідь у форматі JSON.
// text() — парсить відповідь у вигляді тексту (наприклад табличні дані, .csv).
// blob() — використовується для обробки файлів (зображення, аудіо, відео).


// За замовчуванням fetch() не вважає HTTP-коди 404 чи 500 помилками. Тому потрібно вручну перевіряти статус відповіді та 
// створювати помилку для обробки в catch().

// fetch("https://jsonplaceholder.typicode.com/users")
//   .then(response => {
//     if (!response.ok) {
//       throw new Error(`HTTP error! Status: ${response.status}`);
//     }
//     return response.json();
//   })
//   .then(data => {
//     // Data handling
// 		console.log("Отримані дані:", data);
//   })
//   .catch(error => {
//     // Error handling
// 		console.log("Помилка запиту:", error);
//   });

// Чому це важливо?

// fetch() не відхиляє проміс при помилках сервера (наприклад, 404 або 500).
// Щоб виявити невдалий запит, потрібно вручну перевіряти response.ok.
// Якщо response.ok === false, необхідно викликати throw new Error(), щоб помилка оброблялася в catch().

// Такий підхід дозволяє коректно реагувати на помилки та уникати несподіваної поведінки в коді.


//? HTTP-методи

// У REST API використовується кілька основних HTTP-методів для взаємодії з ресурсами:

// POST — створює новий ресурс.
// GET — отримує набір ресурсів або один ресурс.
// PUT — оновлює існуючий ресурс або створює новий.
// PATCH — частково оновлює існуючий ресурс.
// DELETE — видаляє ресурс.

// Наразі нас цікавить GET, який використовується для отримання даних із сервера.
// Метод запиту задається через об’єкт налаштувань, який передається другим аргументом у fetch():

// const options = {
// 	method: "GET"
// };

// fetch("https://jsonplaceholder.typicode.com/users", options)
//   .then(response => {
//     if (!response.ok) {
//       throw new Error(response.status);
//     }
//     return response.json();
//   })
//   .then(data => {
    // Data handling
//   })
//   .catch(error => {
    // Error handling
//   });

// приклад
// Ось приклад, який показує, як саме можна використати отримані дані не просто для console.log, а відрендерити їх на сторінці — вивести імена користувачів у <ul>-списку.

// 🧪 Повний приклад: Рендер користувачів з JSONPlaceholder
// 📄 HTML (самі простіші речі):
// html
// <ul id="user-list"></ul>
// 💻 JavaScript:
// js
// fetch("https://jsonplaceholder.typicode.com/users")
//   .then(response => {
//     if (!response.ok) {
//       throw new Error(`HTTP error! Status: ${response.status}`);
//     }
//     return response.json();
//   })
//   .then(data => {
//     const ul = document.getElementById("user-list");

//     data.forEach(user => {
//       const li = document.createElement("li");
//       li.textContent = `👤 ${user.name} (${user.email})`;
//       ul.appendChild(li);
//     });
//   })
//   .catch(error => {
//     console.error("Помилка запиту:", error);
//   });
// 🧠 Що ми тут обробляємо (Data handling):
// data — це масив користувачів.

// В циклі forEach ми створюємо <li>-елементи з ім'ям і email.

// Цей список додається до <ul> на сторінці.

// 📌 Важливо: цей приклад працює, якщо ти відкрив HTML-файл через Live Server або розміщений сервер, бо CORS може заблокувати 
// прямий доступ із локального файлу.

// Важливі нюанси
// Якщо виконується GETзапит, вказувати method: "GET" не обов’язково, оскільки це значення за замовчуванням.
// Доступні HTTP-методи для кожного ресурсу описані у документації бекенду.
// Використання правильного HTTP-методу гарантує, що сервер обробить запит очікуваним чином.

// todo Test 

// Який HTTP метод використовується для читання даних?

// PATCH
// POST
//* GET
// Result

//* Чудово! Це правильна відповідь.

//? HTTP-заголовки

// HTTP-заголовки містять службову інформацію, що описує запит або відповідь. Кожен заголовок складається з імені та значення. Наприклад:

// Accept — визначає тип контенту, який клієнт може прийняти у відповіді.
// Content-Type — вказує тип контенту, щоб отримувач знав, як його обробити.

// Accept: text/html
// Content-Type: application/json

// Заголовок складається з імені та значення. Значення заголовка — це MIME-тип (тип контенту), який використовується для вказівки типу контенту запиту чи відповіді і складається з типу і підтипу, розділених косою рискою (/). 

// Наприклад:

// text/html — HTML-файл.
// text/css — CSS-файл.
// application/json — JSON-дані.


// Якщо клієнт очікує text/css, а отримує application/json, він не зможе правильно обробити відповідь. Тому заголовки допомагають серверу і клієнту погоджувати формат переданих даних.
// Як переглянути заголовки у браузері?

// У вкладці Network (інструменти розробника) заголовки відповіді видно в секції Response Headers, а заголовки запиту — у Request Headers.
// Як передати заголовки у fetch()?
// Заголовки додаються у властивість headers об’єкта налаштувань:

// fetch("some-url", {
// 	headers: {
// 	  "Content-Type": "application/json",
// 	  "X-Custom-Header": "custom value",
// 	}
// })

// Якщо потрібно вказати, що ми очікуємо відповідь у форматі JSON, додаємо Accept: application/json:

// fetch("https://jsonplaceholder.typicode.com/users", {
//   headers: {
//     Accept: "application/json",
//   },
// }).then(response => {
//   // ...
// });

//? Стандартні заголовки

// Сучасні браузери автоматично додають деякі заголовки, тому їх не потрібно вказувати вручну. Ось найпоширеніші з них:

// User-Agent — ідентифікує браузер або інший клієнтський застосунок.
// Accept — вказує, які формати даних клієнт може обробляти.
// Content-Type — вказує тип контенту в тілі запиту або відповіді.
// Authorization — використовується для передачі токенів аутентифікації.
// Cache-Control — керує кешуванням відповіді.
// Host — містить доменне ім’я сервера, до якого виконується запит.

// Заголовки відіграють ключову роль у взаємодії клієнта та сервера, дозволяючи налаштовувати формат переданих даних і механізми автентифікації.

//? Кросдоменні запити

// За замовчуванням браузери дозволяють виконувати HTTP-запити тільки в межах поточного сайту. Якщо запит робиться на інший домен, порт
// або протокол, браузер блокує його та видає помилку.
// Ця політика безпеки називається CORS (Cross-Origin Resource Sharing), що перекладається як "спільне використання ресурсів між різними 
// джерелами".
// Як працює CORS?
// При кожному HTTP-запиті браузер автоматично додає заголовок Origin, де вказує адресу вебсторінки, яка намагається отримати дані.
// Приклад запиту з вебсторінки https://my-site.com/about на сервер https://my-api.com/users

// GET /users
// Host: my-api.com
// Origin: https://my-site.com

// Сервер перевіряє заголовок Origin і, якщо він дозволяє кросдоменні запити, додає у відповідь спеціальний заголовок Access-Control-Allow-Origin.

// # Доступ тільки для одного сайту
// Access-Control-Allow-Origin: https://my-site.com

// # Доступ для всіх (публічний API)
// Access-Control-Allow-Origin: *

// Як сервер обробляє CORS?

// Якщо Access-Control-Allow-Origin містить конкретний сайт, тільки він може отримати відповідь.
// Якщо значення *, запити дозволені з будь-якого джерела.
// Якщо цей заголовок відсутній, браузер блокує відповідь, і JavaScript-код отримає помилку CORS.

// Браузер виступає посередником між JavaScript-кодом і сервером:

// Додає заголовок Origin до запиту.
// Перевіряє відповідь сервера на наявність Access-Control-Allow-Origin.
// Якщо заголовок присутній і збігається — запит виконується успішно.
// Якщо ні — браузер блокує відповідь і викидає помилку CORS.

// Висновок
// CORS налаштовується на бекенді. Якщо сервер не підтримує кросдоменні запити, фронтенд-розробник не може змінити це у своєму коді. 
// Якщо при виконанні запиту виникає помилка CORS, необхідно перевірити налаштування бекенду та дозволи на доступ.

//!!!   AJAX

//* JAX (Asynchronous JavaScript and XML) — це метод обміну даними між клієнтом і сервером без перезавантаження сторінки. Завдяки цьому 
// вебсторінки стають інтерактивнішими і швидше реагують на дії користувача.

// Дозволяє динамічно оновлювати контент, не перезавантажуючи всю сторінку.
// Зменшує навантаження на сервер, оскільки оновлюються тільки необхідні частини інтерфейсу.
// Використовується в усіх сучасних вебзастосунках, від соцмереж до онлайн-магазинів.

// Таким чином, AJAX — це основа динамічних вебсайтів.

// Як працює AJAX? Процес можна розділити на кілька етапів:

// Користувач виконує дію (наприклад, натискає кнопку "Показати більше" або відправляє форму).
// JavaScript відправляє HTTP-запит до сервера (зазвичай через fetch або axios).
// Сервер отримує запит, обробляє його і повертає відповідь у форматі JSON.
// JavaScript отримує відповідь, обробляє дані і оновлює інтерфейс без перезавантаження сторінки.

// Хоча в назві технології є XML, сьогодні JSON повністю замінив його, оскільки є простішим у використанні. Проте назва AJAX залишилася 
// як історична спадщина. AJAX трактується як будь-яке спілкування з сервером без перезавантаження сторінки.

//? Оновлення інтерфейсу

// Продовжимо працювати з JSONPlaceholder API і візьмемо за приклад простий інтерфейс, у якому будемо відображати список користувачів 
// після натискання кнопки.

// HTML-розмітка:

// <button type="button" class="btn">Fetch users</button>
// <ul class="user-list"></ul>

// При кліку на кнопку Fetch users виконаємо HTTP-запит:

// const fetchUsersBtn = document.querySelector(".btn");

// fetchUsersBtn.addEventListener("click", () => {
//   fetch("https://jsonplaceholder.typicode.com/users")
//     .then((response) => {
//       if (!response.ok) {
//         throw new Error(response.status);
//       }
//       return response.json();
//     })
//     .then((users) => {
// 			// Дані від бекенда
// 			console.log(users);
// 		})
//     .catch((error) => console.log(error));
// });

// У другому блоці then отримуємо доступ до даних відповіді від бекенда. Саме тут можна використати ці дані й оновити інтерфейс, 
// створити HTML-розмітку і додати її в DOM у якийсь уже наявний елемент.

// Для створення HTML-розмітки можна використовувати будь-який зручний спосіб, наприклад createElement або insertAdjacentHTML. 
// Розглянемо одну зі стандартних технік.

// Перебираємо масив об'єктів методом map
// На кожній ітерації повертаємо HTML-розмітку для одного елемента колекції
// Результуючий масив рядків зшиваємо в один рядок методом join("")
// Додаємо рядок з HTML-розміткою в DOM методом insertAdjacentHTML

// const fetchUsersBtn = document.querySelector(".btn");
// const userList = document.querySelector(".user-list");

// fetchUsersBtn.addEventListener("click", () => {
//   fetch("https://jsonplaceholder.typicode.com/users")
//     .then((response) => {
//       if (!response.ok) {
//         throw new Error(response.status);
//       }
//       return response.json();
//     })
//     .then((users) => {
//       const markup = users.map((user) => {
// 				return `<li>
// 	          <p><b>Name</b>: ${user.name}</p>
// 	          <p><b>Email</b>: ${user.email}</p>
// 	          <p><b>Company</b>: ${user.company.name}</p>
// 	        </li>`;
//         })
//         .join("");

// 		userList.insertAdjacentHTML("beforeend", markup);
//     })
//     .catch((error) => console.log(error));
// });

// Розбери живий приклад написаного коду. Зверни увагу, як ми покращили код, щоб зробити його більш читабельним.

// Винесли код запиту у функцію fetchUsers(), яка виконує HTTP-запит і повертає результат - проміс, який в свою чергу повернув метод then.
// В обробнику події кліка ми її викликаємо і до результату її виклику (промісу) додаємо ланцюжок методів then() і catch().
// Винесли код створення й додавання HTML-розмітки у функцію renderUsers(users), яка очікує масив користувачів.

//?   Помилка новачка
// Однією з найбільш типових помилок під час роботи з fetch є спроба використати отримані дані поза колбеком then() у синхронному коді.
// Новачки часто намагаються зберегти результат запиту у змінну і відразу використовувати її:

// let globalVar; // undefined

// 1. Виконуємо HTTP-запит
// fetch("https://jsonplaceholder.typicode.com/users")
//   .then(response => response.json())
//   .then(users => {
//     console.log("users inside then callback: ", users);

    // Асинхронно записуємо результат запиту в зовнішню змінну
    // globalVar = users;

    // Усередині колбека методу then усе добре
    // console.log("globalVar inside fetch callback: ", globalVar);
  // });

// Зовні колбека методу then у синхронному 
// коді немає доступу до даних асинхронної відповіді бекенда
// тому що цей код виконаєтся перед кодом в методі then
// console.log("globalVar outside fetch: ", globalVar); // undefined

// На момент виконання останнього console.log(), змінна globalVar ще не отримала значення, оскільки fetch() працює асинхронно. 
// Код поза then() виконується раніше, ніж запит отримає відповідь.

// Як правильно працювати з даними?
// Замість використання зовнішньої змінної, всі операції з отриманими даними потрібно виконувати всередині then():

// fetch("https://jsonplaceholder.typicode.com/users")
//   .then((response) => response.json())
//   .then((users) => {
	  // Можемо використати тут
//     console.log("Отримані користувачі:", users);
    // Або передати в функцію для обробки
//     renderUsers(users);
//   })
//   .catch((error) => console.log("Помилка:", error));

// Висновок: дані з асинхронного запиту доступні тільки в then(). Використовувати їх у синхронному коді поза then() – помилка. 
// Це один з найважливіших принципів роботи з асинхронністю в JavaScript!

// todo Test
// Чи можна отримати доступ до даних HTTP-запиту поза методом then у синхронному коді?

//* Ні, ці дані є значенням промісу, який асинхронно обробляється методом then
// Так, зберігши їх у глобальну змінну
// Result

// Правильно! Такі дані є значенням промісу, який обробляється методом then. Якщо ти спробуєш зберегти їх у глобальну змінну, 
// ти можеш отримати неочікувані результати, такі як undefined, оскільки синхронний код виконається раніше, ніж проміс буде вирішений.

//?  Параметри рядка запиту

// Параметри запиту дозволяють передавати на бекенд додаткові критерії для отримання потрібних даних. Вони можуть використовуватися для:

// Обмеження кількості результатів (наприклад, отримати лише 7 записів).
// Сортування за певною властивістю (наприклад, за іменем або датою).
// Фільтрації результатів за певними умовами.

// Список доступних параметрів запиту залежить від бекенду і зазвичай описаний у його документації.

// Синтаксис параметрів у URL
// Параметри додаються після ?.
// Кожен параметр — це пара ключ=значення.
// Кілька параметрів розділяються символом &.


// У документації JSONPlaceholder API вказано такі параметри:

// _limit — обмежує кількість записів у відповіді.
// _sort — сортує отримані дані за вказаним полем.

// Підкреслення в іменах параметрів специфічні для цього бекенда, це не якийсь стандарт.

// fetch("https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name")

// Що робить цей запит?

// Повертає 7 користувачів (замість 10, які є за замовчуванням).
// Відсортовує їх за полем name в алфавітному порядку.

// Нижче ми додали використання параметрів рядка запиту до живого прикладу.

// todo Test
// Який символ в URL вказує на початок параметрів рядка запиту?

// *
// &
//*  ?
// !
// Result

//* Точнісінько так!
